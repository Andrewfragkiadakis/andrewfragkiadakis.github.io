(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_async_to_generator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_async_to_generator
]);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
;
}),
"[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_construct.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_construct
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_is_native_reflect_construct$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_is_native_reflect_construct.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_set_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_set_prototype_of.js [app-client] (ecmascript)");
;
;
function _construct(Parent, args, Class) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_is_native_reflect_construct$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])()) _construct = Reflect.construct;
    else {
        _construct = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_set_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
;
}),
"[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_is_native_function.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_is_native_function
]);
function _is_native_function(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
;
}),
"[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_wrap_native_super.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>_wrap_native_super
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_construct$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_construct.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_get_prototype_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_is_native_function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_is_native_function.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_set_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_set_prototype_of.js [app-client] (ecmascript)");
;
;
;
;
function _wrap_native_super(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super = function _wrap_native_super(Class) {
        if (Class === null || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_is_native_function$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_construct$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Class, arguments, (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_set_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Wrapper, Class);
    };
    return _wrap_native_super(Class);
}
;
}),
"[project]/andreas-technology-v2/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript) <export __generator as _>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__generator"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript)");
}),
"[project]/andreas-technology-v2/node_modules/zustand/esm/vanilla.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createStore",
    ()=>createStore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
;
var createStoreImpl = function(createState) {
    var state;
    var listeners = /* @__PURE__ */ new Set();
    var setState = function(partial, replace) {
        var nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
            var previousState = state;
            state = (replace != null ? replace : (typeof nextState === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(nextState)) !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
            listeners.forEach(function(listener) {
                return listener(state, previousState);
            });
        }
    };
    var getState = function() {
        return state;
    };
    var getInitialState = function() {
        return initialState;
    };
    var subscribe = function(listener) {
        listeners.add(listener);
        return function() {
            return listeners["delete"](listener);
        };
    };
    var api = {
        setState: setState,
        getState: getState,
        getInitialState: getInitialState,
        subscribe: subscribe
    };
    var initialState = state = createState(setState, getState, api);
    return api;
};
var createStore = function(createState) {
    return createState ? createStoreImpl(createState) : createStoreImpl;
};
;
}),
"[project]/andreas-technology-v2/node_modules/zustand/esm/traditional.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createWithEqualityFn",
    ()=>createWithEqualityFn,
    "useStoreWithEqualityFn",
    ()=>useStoreWithEqualityFn
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/use-sync-external-store/shim/with-selector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$zustand$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/zustand/esm/vanilla.mjs [app-client] (ecmascript)");
;
;
;
var useSyncExternalStoreWithSelector = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useSyncExternalStoreWithSelector;
var identity = function(arg) {
    return arg;
};
function useStoreWithEqualityFn(api) {
    var selector = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : identity, equalityFn = arguments.length > 2 ? arguments[2] : void 0;
    var slice = useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getInitialState, selector, equalityFn);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useDebugValue(slice);
    return slice;
}
var createWithEqualityFnImpl = function(createState, defaultEqualityFn) {
    var api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$zustand$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"])(createState);
    var useBoundStoreWithEqualityFn = function(selector) {
        var equalityFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultEqualityFn;
        return useStoreWithEqualityFn(api, selector, equalityFn);
    };
    Object.assign(useBoundStoreWithEqualityFn, api);
    return useBoundStoreWithEqualityFn;
};
var createWithEqualityFn = function(createState, defaultEqualityFn) {
    return createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;
};
;
}),
"[project]/andreas-technology-v2/node_modules/suspend-react/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clear",
    ()=>clear,
    "peek",
    ()=>peek,
    "preload",
    ()=>preload,
    "suspend",
    ()=>suspend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_to_consumable_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
;
;
var isPromise = function(promise) {
    return (typeof promise === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(promise)) === 'object' && typeof promise.then === 'function';
};
var globalCache = [];
function shallowEqualArrays(arrA, arrB) {
    var equal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(a, b) {
        return a === b;
    };
    if (arrA === arrB) return true;
    if (!arrA || !arrB) return false;
    var len = arrA.length;
    if (arrB.length !== len) return false;
    for(var i = 0; i < len; i++)if (!equal(arrA[i], arrB[i])) return false;
    return true;
}
function query(fn) {
    var keys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, preload = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, config = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    // If no keys were given, the function is the key
    if (keys === null) keys = [
        fn
    ];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = globalCache[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var entry = _step.value;
            // Find a match
            if (shallowEqualArrays(keys, entry.keys, entry.equal)) {
                // If we're pre-loading and the element is present, just return
                if (preload) return undefined; // If an error occurred, throw
                if (Object.prototype.hasOwnProperty.call(entry, 'error')) throw entry.error; // If a response was successful, return
                if (Object.prototype.hasOwnProperty.call(entry, 'response')) {
                    if (config.lifespan && config.lifespan > 0) {
                        if (entry.timeout) clearTimeout(entry.timeout);
                        entry.timeout = setTimeout(entry.remove, config.lifespan);
                    }
                    return entry.response;
                } // If the promise is still unresolved, throw
                if (!preload) throw entry.promise;
            }
        } // The request is new or has changed.
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    var entry1 = {
        keys: keys,
        equal: config.equal,
        remove: function() {
            var index = globalCache.indexOf(entry1);
            if (index !== -1) globalCache.splice(index, 1);
        },
        promise: (isPromise(fn) ? fn : fn.apply(void 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(keys)) // When it resolves, store its value
        ).then(function(response) {
            entry1.response = response; // Remove the entry in time if a lifespan was given
            if (config.lifespan && config.lifespan > 0) {
                entry1.timeout = setTimeout(entry1.remove, config.lifespan);
            }
        }) // Store caught errors, they will be thrown in the render-phase to bubble into an error-bound
        ["catch"](function(error) {
            return entry1.error = error;
        })
    }; // Register the entry
    globalCache.push(entry1); // And throw the promise, this yields control back to React
    if (!preload) throw entry1.promise;
    return undefined;
}
var suspend = function(fn, keys, config) {
    return query(fn, keys, false, config);
};
var preload = function(fn, keys, config) {
    return void query(fn, keys, true, config);
};
var peek = function(keys) {
    var _globalCache$find;
    return (_globalCache$find = globalCache.find(function(entry) {
        return shallowEqualArrays(keys, entry.keys, entry.equal);
    })) == null ? void 0 : _globalCache$find.response;
};
var clear = function(keys) {
    if (keys === undefined || keys.length === 0) globalCache.splice(0, globalCache.length);
    else {
        var entry = globalCache.find(function(entry) {
            return shallowEqualArrays(keys, entry.keys, entry.equal);
        });
        if (entry) entry.remove();
    }
};
;
}),
"[project]/andreas-technology-v2/node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
var _type_of = __turbopack_context__.r("[project]/andreas-technology-v2/node_modules/@swc/helpers/cjs/_type_of.cjs [app-client] (ecmascript)");
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function performWorkUntilDeadline() {
        if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = !0;
            try {
                a: {
                    isHostCallbackScheduled = !1;
                    isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                    isPerformingWork = !0;
                    var previousPriorityLevel = currentPriorityLevel;
                    try {
                        b: {
                            advanceTimers(currentTime);
                            for(currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());){
                                var callback = currentTask.callback;
                                if ("function" === typeof callback) {
                                    currentTask.callback = null;
                                    currentPriorityLevel = currentTask.priorityLevel;
                                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                                    currentTime = exports.unstable_now();
                                    if ("function" === typeof continuationCallback) {
                                        currentTask.callback = continuationCallback;
                                        advanceTimers(currentTime);
                                        hasMoreWork = !0;
                                        break b;
                                    }
                                    currentTask === peek(taskQueue) && pop(taskQueue);
                                    advanceTimers(currentTime);
                                } else pop(taskQueue);
                                currentTask = peek(taskQueue);
                            }
                            if (null !== currentTask) hasMoreWork = !0;
                            else {
                                var firstTimer = peek(timerQueue);
                                null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                                hasMoreWork = !1;
                            }
                        }
                        break a;
                    } finally{
                        currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
                    }
                    hasMoreWork = void 0;
                }
            } finally{
                hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
            }
        }
    }
    function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for(; 0 < index;){
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
        }
    }
    function peek(heap) {
        return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
            heap[0] = last;
            a: for(var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;){
                var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
                if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
                else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;
                else break a;
            }
        }
        return first;
    }
    function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
        for(var timer = peek(timerQueue); null !== timer;){
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
        }
    }
    function handleTimeout(currentTime) {
        isHostTimeoutScheduled = !1;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, requestHostCallback();
        else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    function shouldYieldToHost() {
        return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostCallback() {
        isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
    }
    function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
        }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if ("object" === (typeof performance === "undefined" ? "undefined" : _type_of._(performance)) && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
            return localPerformance.now();
        };
    } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
            return localDate.now() - initialTime;
        };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = !1, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if ("function" === typeof localSetImmediate) var schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
        localSetImmediate(performWorkUntilDeadline);
    };
    else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
            port.postMessage(null);
        };
    } else schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
        localSetTimeout(performWorkUntilDeadline, 0);
    };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
        task.callback = null;
    };
    exports.unstable_continueExecution = function() {
        isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback());
    };
    exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function() {
        return peek(taskQueue);
    };
    exports.unstable_next = function(eventHandler) {
        switch(currentPriorityLevel){
            case 1:
            case 2:
            case 3:
                var priorityLevel = 3;
                break;
            default:
                priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_pauseExecution = function() {};
    exports.unstable_requestPaint = function() {};
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch(priorityLevel){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === (typeof options === "undefined" ? "undefined" : _type_of._(options)) && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch(priorityLevel){
            case 1:
                var timeout = -1;
                break;
            case 2:
                timeout = 250;
                break;
            case 5:
                timeout = 1073741823;
                break;
            case 4:
                timeout = 1e4;
                break;
            default:
                timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback()));
        return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
                return callback.apply(this, arguments);
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/andreas-technology-v2/node_modules/react-reconciler/node_modules/scheduler/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/andreas-technology-v2/node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.development.js [app-client] (ecmascript)");
}
}),
"[project]/andreas-technology-v2/node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
var _type_of = __turbopack_context__.r("[project]/andreas-technology-v2/node_modules/@swc/helpers/cjs/_type_of.cjs [app-client] (ecmascript)");
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function performWorkUntilDeadline() {
        if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = !0;
            try {
                a: {
                    isHostCallbackScheduled = !1;
                    isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                    isPerformingWork = !0;
                    var previousPriorityLevel = currentPriorityLevel;
                    try {
                        b: {
                            advanceTimers(currentTime);
                            for(currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());){
                                var callback = currentTask.callback;
                                if ("function" === typeof callback) {
                                    currentTask.callback = null;
                                    currentPriorityLevel = currentTask.priorityLevel;
                                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                                    currentTime = exports.unstable_now();
                                    if ("function" === typeof continuationCallback) {
                                        currentTask.callback = continuationCallback;
                                        advanceTimers(currentTime);
                                        hasMoreWork = !0;
                                        break b;
                                    }
                                    currentTask === peek(taskQueue) && pop(taskQueue);
                                    advanceTimers(currentTime);
                                } else pop(taskQueue);
                                currentTask = peek(taskQueue);
                            }
                            if (null !== currentTask) hasMoreWork = !0;
                            else {
                                var firstTimer = peek(timerQueue);
                                null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                                hasMoreWork = !1;
                            }
                        }
                        break a;
                    } finally{
                        currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
                    }
                    hasMoreWork = void 0;
                }
            } finally{
                hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
            }
        }
    }
    function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for(; 0 < index;){
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
        }
    }
    function peek(heap) {
        return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
            heap[0] = last;
            a: for(var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;){
                var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
                if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
                else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;
                else break a;
            }
        }
        return first;
    }
    function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
        for(var timer = peek(timerQueue); null !== timer;){
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
        }
    }
    function handleTimeout(currentTime) {
        isHostTimeoutScheduled = !1;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, requestHostCallback();
        else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    function shouldYieldToHost() {
        return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
    }
    function requestHostCallback() {
        isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
    }
    function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
        }, ms);
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = void 0;
    if ("object" === (typeof performance === "undefined" ? "undefined" : _type_of._(performance)) && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
            return localPerformance.now();
        };
    } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
            return localDate.now() - initialTime;
        };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = !1, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if ("function" === typeof localSetImmediate) var schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
        localSetImmediate(performWorkUntilDeadline);
    };
    else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
            port.postMessage(null);
        };
    } else schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
        localSetTimeout(performWorkUntilDeadline, 0);
    };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
        task.callback = null;
    };
    exports.unstable_continueExecution = function() {
        isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback());
    };
    exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function() {
        return peek(taskQueue);
    };
    exports.unstable_next = function(eventHandler) {
        switch(currentPriorityLevel){
            case 1:
            case 2:
            case 3:
                var priorityLevel = 3;
                break;
            default:
                priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_pauseExecution = function() {};
    exports.unstable_requestPaint = function() {};
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch(priorityLevel){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
            return eventHandler();
        } finally{
            currentPriorityLevel = previousPriorityLevel;
        }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === (typeof options === "undefined" ? "undefined" : _type_of._(options)) && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch(priorityLevel){
            case 1:
                var timeout = -1;
                break;
            case 2:
                timeout = 250;
                break;
            case 5:
                timeout = 1073741823;
                break;
            case 4:
                timeout = 1e4;
                break;
            default:
                timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
            id: taskIdCounter++,
            callback: callback,
            priorityLevel: priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback()));
        return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
                return callback.apply(this, arguments);
            } finally{
                currentPriorityLevel = previousPriorityLevel;
            }
        };
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/andreas-technology-v2/node_modules/@react-three/fiber/node_modules/scheduler/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/andreas-technology-v2/node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js [app-client] (ecmascript)");
}
}),
"[project]/andreas-technology-v2/node_modules/its-fine/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FiberProvider",
    ()=>m,
    "traverseFiber",
    ()=>i,
    "useContainer",
    ()=>w,
    "useContextBridge",
    ()=>x,
    "useContextMap",
    ()=>h,
    "useFiber",
    ()=>c,
    "useNearestChild",
    ()=>v,
    "useNearestParent",
    ()=>y
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread_props.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
var f = /* @__PURE__ */ function() {
    var e, t;
    return typeof window != "undefined" && (((e = window.document) == null ? void 0 : e.createElement) || ((t = window.navigator) == null ? void 0 : t.product) === "ReactNative");
}() ? __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
function i(e, t, r) {
    if (!e) return;
    if (r(e) === !0) return e;
    var n = t ? e["return"] : e.child;
    for(; n;){
        var u = i(n, t, r);
        if (u) return u;
        n = t ? null : n.sibling;
    }
}
function l(e) {
    try {
        return Object.defineProperties(e, {
            _currentRenderer: {
                get: function get() {
                    return null;
                },
                set: function set() {}
            },
            _currentRenderer2: {
                get: function get() {
                    return null;
                },
                set: function set() {}
            }
        });
    } catch (t) {
        return e;
    }
}
var a = /* @__PURE__ */ l(/* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](null));
var m = /*#__PURE__*/ function(_o_Component) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(m, _o_Component);
    function m() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, m);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, m, arguments);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(m, [
        {
            key: "render",
            value: function render() {
                return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](a.Provider, {
                    value: this._reactInternals
                }, this.props.children);
            }
        }
    ]);
    return m;
}(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Component"]);
function c() {
    var e = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](a);
    if (e === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    var t = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useId"]();
    return __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "c.useMemo": function() {
            for(var _i = 0, _iter = [
                e,
                e == null ? void 0 : e.alternate
            ]; _i < _iter.length; _i++){
                var n = _iter[_i];
                if (!n) continue;
                var u = i(n, !1, {
                    "c.useMemo.u": function(d) {
                        var s = d.memoizedState;
                        for(; s;){
                            if (s.memoizedState === t) return !0;
                            s = s.next;
                        }
                    }
                }["c.useMemo.u"]);
                if (u) return u;
            }
        }
    }["c.useMemo"], [
        e,
        t
    ]);
}
function w() {
    var e = c(), t = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "w.useMemo[t]": function() {
            return i(e, !0, {
                "w.useMemo[t]": function(r) {
                    var n;
                    return ((n = r.stateNode) == null ? void 0 : n.containerInfo) != null;
                }
            }["w.useMemo[t]"]);
        }
    }["w.useMemo[t]"], [
        e
    ]);
    return t == null ? void 0 : t.stateNode.containerInfo;
}
function v(e) {
    var t = c(), r = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
    return f(function() {
        var n;
        r.current = (n = i(t, !1, function(u) {
            return typeof u.type == "string" && (e === void 0 || u.type === e);
        })) == null ? void 0 : n.stateNode;
    }, [
        t
    ]), r;
}
function y(e) {
    var t = c(), r = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](void 0);
    return f(function() {
        var n;
        r.current = (n = i(t, !0, function(u) {
            return typeof u.type == "string" && (e === void 0 || u.type === e);
        })) == null ? void 0 : n.stateNode;
    }, [
        t
    ]), r;
}
var p = Symbol["for"]("react.context"), b = function(e) {
    return e !== null && (typeof e === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(e)) == "object" && "$$typeof" in e && e.$$typeof === p;
};
function h() {
    var e = c(), _o_useState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "h._o_useState.useState": function() {
            return /* @__PURE__ */ new Map();
        }
    }["h._o_useState.useState"]), 1), t = _o_useState[0];
    t.clear();
    var r = e;
    for(; r;){
        var n = r.type;
        b(n) && n !== a && !t.has(n) && t.set(n, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["use"](l(n))), r = r["return"];
    }
    return t;
}
function x() {
    var e = h();
    return __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "x.useMemo": function() {
            return Array.from(e.keys()).reduce({
                "x.useMemo": function(t, r) {
                    return ({
                        "x.useMemo": function(n) {
                            return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](t, null, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](r.Provider, (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, n), {
                                value: e.get(r)
                            })));
                        }
                    })["x.useMemo"];
                }
            }["x.useMemo"], {
                "x.useMemo": function(t) {
                    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](m, (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, t));
                }
            }["x.useMemo"]);
        }
    }["x.useMemo"], [
        e
    ]);
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/andreas-technology-v2/node_modules/react-use-measure/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>j
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_to_consumable_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
;
;
;
function g(n, t) {
    var o;
    return function() {
        for(var _len = arguments.length, i = new Array(_len), _key = 0; _key < _len; _key++){
            i[_key] = arguments[_key];
        }
        window.clearTimeout(o), o = window.setTimeout(function() {
            return n.apply(void 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(i));
        }, t);
    };
}
function j() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    }, n = _ref.debounce, t = _ref.scroll, o = _ref.polyfill, i = _ref.offsetSize;
    var a = o || (typeof window == "undefined" ? function _class() {
        "use strict";
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, _class);
    } : window.ResizeObserver);
    if (!a) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    var _T = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    }), 2), c = _T[0], h = _T[1], e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: c,
        orientationHandler: null
    }), d = n ? typeof n == "number" ? n : n.scroll : null, f = n ? typeof n == "number" ? n : n.resize : null, w = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(!1);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        return w.current = !0, function() {
            return void (w.current = !1);
        };
    });
    var _M = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])(function() {
        var r = function() {
            if (!e.current.element) return;
            var _e_current_element_getBoundingClientRect = e.current.element.getBoundingClientRect(), y = _e_current_element_getBoundingClientRect.left, C = _e_current_element_getBoundingClientRect.top, H = _e_current_element_getBoundingClientRect.width, O = _e_current_element_getBoundingClientRect.height, S = _e_current_element_getBoundingClientRect.bottom, x = _e_current_element_getBoundingClientRect.right, B = _e_current_element_getBoundingClientRect.x, R = _e_current_element_getBoundingClientRect.y, l = {
                left: y,
                top: C,
                width: H,
                height: O,
                bottom: S,
                right: x,
                x: B,
                y: R
            };
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(e.current.element, HTMLElement) && i && (l.height = e.current.element.offsetHeight, l.width = e.current.element.offsetWidth), Object.freeze(l), w.current && !D(e.current.lastBounds, l) && h(e.current.lastBounds = l);
        };
        return [
            r,
            f ? g(r, f) : r,
            d ? g(r, d) : r
        ];
    }, [
        h,
        i,
        d,
        f
    ]), 3), z = _M[0], m = _M[1], s = _M[2];
    function v() {
        e.current.scrollContainers && (e.current.scrollContainers.forEach(function(r) {
            return r.removeEventListener("scroll", s, !0);
        }), e.current.scrollContainers = null), e.current.resizeObserver && (e.current.resizeObserver.disconnect(), e.current.resizeObserver = null), e.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", e.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", e.current.orientationHandler));
    }
    function b() {
        e.current.element && (e.current.resizeObserver = new a(s), e.current.resizeObserver.observe(e.current.element), t && e.current.scrollContainers && e.current.scrollContainers.forEach(function(r) {
            return r.addEventListener("scroll", s, {
                capture: !0,
                passive: !0
            });
        }), e.current.orientationHandler = function() {
            s();
        }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", e.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", e.current.orientationHandler));
    }
    var L = function(r) {
        !r || r === e.current.element || (v(), e.current.element = r, e.current.scrollContainers = E(r), b());
    };
    return X(s, !!t), W(m), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        v(), b();
    }, [
        t,
        s,
        m
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        return v;
    }, []), [
        L,
        c,
        z
    ];
}
function W(n) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        var t = n;
        return window.addEventListener("resize", t), function() {
            return void window.removeEventListener("resize", t);
        };
    }, [
        n
    ]);
}
function X(n, t) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function() {
        if (t) {
            var o = n;
            return window.addEventListener("scroll", o, {
                capture: !0,
                passive: !0
            }), function() {
                return void window.removeEventListener("scroll", o, !0);
            };
        }
    }, [
        n,
        t
    ]);
}
function E(n) {
    var t = [];
    if (!n || n === document.body) return t;
    var _window_getComputedStyle = window.getComputedStyle(n), o = _window_getComputedStyle.overflow, i = _window_getComputedStyle.overflowX, a = _window_getComputedStyle.overflowY;
    return [
        o,
        i,
        a
    ].some(function(c) {
        return c === "auto" || c === "scroll";
    }) && t.push(n), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(t).concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(E(n.parentElement)));
}
var k = [
    "x",
    "y",
    "top",
    "bottom",
    "left",
    "right",
    "width",
    "height"
], D = function(n, t) {
    return k.every(function(o) {
        return n[o] === t[o];
    });
};
;
 //# sourceMappingURL=index.js.map
}),
"[project]/andreas-technology-v2/node_modules/@react-three/drei/core/Float.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Float",
    ()=>Float
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_without_properties.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__D__as__useFrame$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export D as useFrame>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
;
var Float = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"](function(_param, forwardRef) {
    var children = _param.children, _param_enabled = _param.enabled, enabled = _param_enabled === void 0 ? true : _param_enabled, _param_speed = _param.speed, speed = _param_speed === void 0 ? 1 : _param_speed, _param_rotationIntensity = _param.rotationIntensity, rotationIntensity = _param_rotationIntensity === void 0 ? 1 : _param_rotationIntensity, _param_floatIntensity = _param.floatIntensity, floatIntensity = _param_floatIntensity === void 0 ? 1 : _param_floatIntensity, _param_floatingRange = _param.floatingRange, floatingRange = _param_floatingRange === void 0 ? [
        -0.1,
        0.1
    ] : _param_floatingRange, _param_autoInvalidate = _param.autoInvalidate, autoInvalidate = _param_autoInvalidate === void 0 ? false : _param_autoInvalidate, props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_param, [
        "children",
        "enabled",
        "speed",
        "rotationIntensity",
        "floatIntensity",
        "floatingRange",
        "autoInvalidate"
    ]);
    var ref = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"](forwardRef, {
        "Float.useImperativeHandle": function() {
            return ref.current;
        }
    }["Float.useImperativeHandle"], []);
    var offset = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](Math.random() * 10000);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__D__as__useFrame$3e$__["useFrame"])({
        "Float.useFrame": function(state) {
            var _floatingRange$, _floatingRange$2;
            if (!enabled || speed === 0) return;
            if (autoInvalidate) state.invalidate();
            var t = offset.current + state.clock.elapsedTime;
            ref.current.rotation.x = Math.cos(t / 4 * speed) / 8 * rotationIntensity;
            ref.current.rotation.y = Math.sin(t / 4 * speed) / 8 * rotationIntensity;
            ref.current.rotation.z = Math.sin(t / 4 * speed) / 20 * rotationIntensity;
            var yPosition = Math.sin(t / 4 * speed) / 10;
            yPosition = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathUtils"].mapLinear(yPosition, -0.1, 0.1, (_floatingRange$ = floatingRange == null ? void 0 : floatingRange[0]) !== null && _floatingRange$ !== void 0 ? _floatingRange$ : -0.1, (_floatingRange$2 = floatingRange == null ? void 0 : floatingRange[1]) !== null && _floatingRange$2 !== void 0 ? _floatingRange$2 : 0.1);
            ref.current.position.y = yPosition * floatIntensity;
            ref.current.updateMatrix();
        }
    }["Float.useFrame"]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("group", props, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("group", {
        ref: ref,
        matrixAutoUpdate: false
    }, children));
});
;
}),
"[project]/andreas-technology-v2/node_modules/@react-three/drei/core/ContactShadows.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ContactShadows",
    ()=>ContactShadows
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread_props.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_without_properties.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export C as useThree>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__D__as__useFrame$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export D as useFrame>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$HorizontalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three-stdlib/shaders/HorizontalBlurShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$VerticalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three-stdlib/shaders/VerticalBlurShader.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
var ContactShadows = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"](function(_param, fref) {
    var _param_scale = _param.scale, scale = _param_scale === void 0 ? 10 : _param_scale, _param_frames = _param.frames, frames = _param_frames === void 0 ? Infinity : _param_frames, _param_opacity = _param.opacity, opacity = _param_opacity === void 0 ? 1 : _param_opacity, _param_width = _param.width, width = _param_width === void 0 ? 1 : _param_width, _param_height = _param.height, height = _param_height === void 0 ? 1 : _param_height, _param_blur = _param.blur, blur = _param_blur === void 0 ? 1 : _param_blur, _param_near = _param.near, near = _param_near === void 0 ? 0 : _param_near, _param_far = _param.far, far = _param_far === void 0 ? 10 : _param_far, _param_resolution = _param.resolution, resolution = _param_resolution === void 0 ? 512 : _param_resolution, _param_smooth = _param.smooth, smooth = _param_smooth === void 0 ? true : _param_smooth, _param_color = _param.color, color = _param_color === void 0 ? '#000000' : _param_color, _param_depthWrite = _param.depthWrite, depthWrite = _param_depthWrite === void 0 ? false : _param_depthWrite, renderOrder = _param.renderOrder, props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_param, [
        "scale",
        "frames",
        "opacity",
        "width",
        "height",
        "blur",
        "near",
        "far",
        "resolution",
        "smooth",
        "color",
        "depthWrite",
        "renderOrder"
    ]);
    var ref = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    var scene = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__["useThree"])({
        "ContactShadows.useThree[scene]": function(state) {
            return state.scene;
        }
    }["ContactShadows.useThree[scene]"]);
    var gl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__["useThree"])({
        "ContactShadows.useThree[gl]": function(state) {
            return state.gl;
        }
    }["ContactShadows.useThree[gl]"]);
    var shadowCamera = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    width = width * (Array.isArray(scale) ? scale[0] : scale || 1);
    height = height * (Array.isArray(scale) ? scale[1] : scale || 1);
    var _React_useMemo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "ContactShadows._React_useMemo.useMemo": function() {
            var renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](resolution, resolution);
            var renderTargetBlur = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](resolution, resolution);
            renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;
            var planeGeometry = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](width, height).rotateX(Math.PI / 2);
            var blurPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](planeGeometry);
            var depthMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshDepthMaterial"]();
            depthMaterial.depthTest = depthMaterial.depthWrite = false;
            depthMaterial.onBeforeCompile = ({
                "ContactShadows._React_useMemo.useMemo": function(shader) {
                    shader.uniforms = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, shader.uniforms), {
                        ucolor: {
                            value: new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"](color)
                        }
                    });
                    shader.fragmentShader = shader.fragmentShader.replace("void main() {", //
                    "uniform vec3 ucolor;\n           void main() {\n          ");
                    shader.fragmentShader = shader.fragmentShader.replace('vec4( vec3( 1.0 - fragCoordZ ), opacity );', // Colorize the shadow, multiply by the falloff so that the center can remain darker
                    'vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );');
                }
            })["ContactShadows._React_useMemo.useMemo"];
            var horizontalBlurMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"](__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$HorizontalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HorizontalBlurShader"]);
            var verticalBlurMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"](__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$shaders$2f$VerticalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VerticalBlurShader"]);
            verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;
            return [
                renderTarget,
                planeGeometry,
                depthMaterial,
                blurPlane,
                horizontalBlurMaterial,
                verticalBlurMaterial,
                renderTargetBlur
            ];
        }
    }["ContactShadows._React_useMemo.useMemo"], [
        resolution,
        width,
        height,
        scale,
        color
    ]), 7), renderTarget = _React_useMemo[0], planeGeometry = _React_useMemo[1], depthMaterial = _React_useMemo[2], blurPlane = _React_useMemo[3], horizontalBlurMaterial = _React_useMemo[4], verticalBlurMaterial = _React_useMemo[5], renderTargetBlur = _React_useMemo[6];
    var blurShadows = function(blur) {
        blurPlane.visible = true;
        blurPlane.material = horizontalBlurMaterial;
        horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;
        horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;
        gl.setRenderTarget(renderTargetBlur);
        gl.render(blurPlane, shadowCamera.current);
        blurPlane.material = verticalBlurMaterial;
        verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;
        verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;
        gl.setRenderTarget(renderTarget);
        gl.render(blurPlane, shadowCamera.current);
        blurPlane.visible = false;
    };
    var count = 0;
    var initialBackground;
    var initialOverrideMaterial;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__D__as__useFrame$3e$__["useFrame"])({
        "ContactShadows.useFrame": function() {
            if (shadowCamera.current && (frames === Infinity || count < frames)) {
                count++;
                initialBackground = scene.background;
                initialOverrideMaterial = scene.overrideMaterial;
                ref.current.visible = false;
                scene.background = null;
                scene.overrideMaterial = depthMaterial;
                gl.setRenderTarget(renderTarget);
                gl.render(scene, shadowCamera.current);
                blurShadows(blur);
                if (smooth) blurShadows(blur * 0.4);
                gl.setRenderTarget(null);
                ref.current.visible = true;
                scene.overrideMaterial = initialOverrideMaterial;
                scene.background = initialBackground;
            }
        }
    }["ContactShadows.useFrame"]);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"](fref, {
        "ContactShadows.useImperativeHandle": function() {
            return ref.current;
        }
    }["ContactShadows.useImperativeHandle"], []);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("group", (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
        "rotation-x": Math.PI / 2
    }, props, {
        ref: ref
    }), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("mesh", {
        renderOrder: renderOrder,
        geometry: planeGeometry,
        scale: [
            1,
            -1,
            1
        ],
        rotation: [
            -Math.PI / 2,
            0,
            0
        ]
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("meshBasicMaterial", {
        transparent: true,
        map: renderTarget.texture,
        opacity: opacity,
        depthWrite: depthWrite
    })), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("orthographicCamera", {
        ref: shadowCamera,
        args: [
            -width / 2,
            width / 2,
            height / 2,
            -height / 2,
            near,
            far
        ]
    }));
});
;
}),
"[project]/andreas-technology-v2/node_modules/@react-three/drei/helpers/environment-assets.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "presetsObj",
    ()=>presetsObj
]);
var presetsObj = {
    apartment: 'lebombo_1k.hdr',
    city: 'potsdamer_platz_1k.hdr',
    dawn: 'kiara_1_dawn_1k.hdr',
    forest: 'forest_slope_1k.hdr',
    lobby: 'st_fagans_interior_1k.hdr',
    night: 'dikhololo_night_1k.hdr',
    park: 'rooitou_park_1k.hdr',
    studio: 'studio_small_03_1k.hdr',
    sunset: 'venice_sunset_1k.hdr',
    warehouse: 'empty_warehouse_01_1k.hdr'
};
;
}),
"[project]/andreas-technology-v2/node_modules/@react-three/drei/core/useEnvironment.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useEnvironment",
    ()=>useEnvironment
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export C as useThree>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export G as useLoader>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$RGBELoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three-stdlib/loaders/RGBELoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$EXRLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three-stdlib/loaders/EXRLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@monogrid/gainmap-js/dist/decode.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$helpers$2f$environment$2d$assets$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/drei/helpers/environment-assets.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
var CUBEMAP_ROOT = 'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/';
var isArray = function(arr) {
    return Array.isArray(arr);
};
var defaultFiles = [
    '/px.png',
    '/nx.png',
    '/py.png',
    '/ny.png',
    '/pz.png',
    '/nz.png'
];
function useEnvironment() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref_files = _ref.files, files = _ref_files === void 0 ? defaultFiles : _ref_files, _ref_path = _ref.path, path = _ref_path === void 0 ? '' : _ref_path, _ref_preset = _ref.preset, preset = _ref_preset === void 0 ? undefined : _ref_preset, _ref_colorSpace = _ref.colorSpace, colorSpace = _ref_colorSpace === void 0 ? undefined : _ref_colorSpace, extensions = _ref.extensions;
    if (preset) {
        validatePreset(preset);
        files = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$helpers$2f$environment$2d$assets$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["presetsObj"][preset];
        path = CUBEMAP_ROOT;
    }
    // Everything else
    var multiFile = isArray(files);
    var _getExtension = getExtension(files), extension = _getExtension.extension, isCubemap = _getExtension.isCubemap;
    var loader = getLoader(extension);
    if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);
    var gl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__["useThree"])({
        "useEnvironment.useThree[gl]": function(state) {
            return state.gl;
        }
    }["useEnvironment.useThree[gl]"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "useEnvironment.useLayoutEffect": function() {
            var clearGainmapTexture = function clearGainmapTexture() {
                __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__["useLoader"].clear(loader, multiFile ? [
                    files
                ] : files);
            };
            // Only required for gainmap
            if (extension !== 'webp' && extension !== 'jpg' && extension !== 'jpeg') return;
            gl.domElement.addEventListener('webglcontextlost', clearGainmapTexture, {
                once: true
            });
        }
    }["useEnvironment.useLayoutEffect"], [
        files,
        gl.domElement
    ]);
    var loaderResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__["useLoader"])(loader, multiFile ? [
        files
    ] : files, {
        "useEnvironment.useLoader[loaderResult]": function(loader) {
            // Gainmap requires a renderer
            if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {
                // @ts-expect-error
                loader.setRenderer(gl);
            }
            loader.setPath == null || loader.setPath(path);
            // @ts-expect-error
            if (extensions) extensions(loader);
        }
    }["useEnvironment.useLoader[loaderResult]"]);
    var texture = multiFile ? // @ts-ignore
    loaderResult[0] : loaderResult;
    if (extension === 'jpg' || extension === 'jpeg' || extension === 'webp') {
        var _renderTarget;
        texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;
    }
    texture.mapping = isCubemap ? __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CubeReflectionMapping"] : __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EquirectangularReflectionMapping"];
    texture.colorSpace = colorSpace !== null && colorSpace !== void 0 ? colorSpace : isCubemap ? 'srgb' : 'srgb-linear';
    return texture;
}
var preloadDefaultOptions = {
    files: defaultFiles,
    path: '',
    preset: undefined,
    extensions: undefined
};
useEnvironment.preload = function(preloadOptions) {
    var options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, preloadDefaultOptions, preloadOptions);
    var files = options.files, _options_path = options.path, path = _options_path === void 0 ? '' : _options_path;
    var preset = options.preset, extensions = options.extensions;
    if (preset) {
        validatePreset(preset);
        files = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$helpers$2f$environment$2d$assets$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["presetsObj"][preset];
        path = CUBEMAP_ROOT;
    }
    var extension = getExtension(files).extension;
    if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {
        throw new Error('useEnvironment: Preloading gainmaps is not supported');
    }
    var loader = getLoader(extension);
    if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__["useLoader"].preload(loader, isArray(files) ? [
        files
    ] : files, function(loader) {
        loader.setPath == null || loader.setPath(path);
        // @ts-expect-error
        if (extensions) extensions(loader);
    });
};
var clearDefaultOptins = {
    files: defaultFiles,
    preset: undefined
};
useEnvironment.clear = function(clearOptions) {
    var options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, clearDefaultOptins, clearOptions);
    var files = options.files;
    var preset = options.preset;
    if (preset) {
        validatePreset(preset);
        files = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$helpers$2f$environment$2d$assets$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["presetsObj"][preset];
    }
    var extension = getExtension(files).extension;
    var loader = getLoader(extension);
    if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__G__as__useLoader$3e$__["useLoader"].clear(loader, isArray(files) ? [
        files
    ] : files);
};
function validatePreset(preset) {
    if (!(preset in __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$helpers$2f$environment$2d$assets$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["presetsObj"])) throw new Error('Preset must be one of: ' + Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$helpers$2f$environment$2d$assets$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["presetsObj"]).join(', '));
}
function getExtension(files) {
    var _firstEntry$split$pop;
    var isCubemap = isArray(files) && files.length === 6;
    var isGainmap = isArray(files) && files.length === 3 && files.some(function(file) {
        return file.endsWith('json');
    });
    var firstEntry = isArray(files) ? files[0] : files;
    // Everything else
    var extension = isCubemap ? 'cube' : isGainmap ? 'webp' : firstEntry.startsWith('data:application/exr') ? 'exr' : firstEntry.startsWith('data:application/hdr') ? 'hdr' : firstEntry.startsWith('data:image/jpeg') ? 'jpg' : (_firstEntry$split$pop = firstEntry.split('.').pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split('?')) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();
    return {
        extension: extension,
        isCubemap: isCubemap,
        isGainmap: isGainmap
    };
}
function getLoader(extension) {
    var loader = extension === 'cube' ? __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CubeTextureLoader"] : extension === 'hdr' ? __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$RGBELoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBELoader"] : extension === 'exr' ? __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$loaders$2f$EXRLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXRLoader"] : extension === 'jpg' || extension === 'jpeg' ? __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["HDRJPGLoader"] : extension === 'webp' ? __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["GainMapLoader"] : null;
    return loader;
}
;
}),
"[project]/andreas-technology-v2/node_modules/@react-three/drei/core/Environment.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Environment",
    ()=>Environment,
    "EnvironmentCube",
    ()=>EnvironmentCube,
    "EnvironmentMap",
    ()=>EnvironmentMap,
    "EnvironmentPortal",
    ()=>EnvironmentPortal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_without_properties.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export C as useThree>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__D__as__useFrame$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export D as useFrame>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__o__as__createPortal$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export o as createPortal>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__applyProps$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export s as applyProps>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__extend$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/fiber/dist/events-1eccaf1c.esm.js [app-client] (ecmascript) <export e as extend>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$GroundProjectedEnv$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three-stdlib/objects/GroundProjectedEnv.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$core$2f$useEnvironment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@react-three/drei/core/useEnvironment.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
var isRef = function(obj) {
    return obj.current && obj.current.isScene;
};
var resolveScene = function(scene) {
    return isRef(scene) ? scene.current : scene;
};
function setEnvProps(background, scene, defaultScene, texture) {
    var sceneProps = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    var _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;
    // defaults
    sceneProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({
        backgroundBlurriness: 0,
        backgroundIntensity: 1,
        backgroundRotation: [
            0,
            0,
            0
        ],
        environmentIntensity: 1,
        environmentRotation: [
            0,
            0,
            0
        ]
    }, sceneProps);
    var target = resolveScene(scene || defaultScene);
    var oldbg = target.background;
    var oldenv = target.environment;
    var oldSceneProps = {
        // @ts-ignore
        backgroundBlurriness: target.backgroundBlurriness,
        // @ts-ignore
        backgroundIntensity: target.backgroundIntensity,
        // @ts-ignore
        backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [
            0,
            0,
            0
        ],
        // @ts-ignore
        environmentIntensity: target.environmentIntensity,
        // @ts-ignore
        environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [
            0,
            0,
            0
        ]
    };
    if (background !== 'only') target.environment = texture;
    if (background) target.background = texture;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__applyProps$3e$__["applyProps"])(target, sceneProps);
    return function() {
        if (background !== 'only') target.environment = oldenv;
        if (background) target.background = oldbg;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__applyProps$3e$__["applyProps"])(target, oldSceneProps);
    };
}
function EnvironmentMap(_param) {
    var scene = _param.scene, _param_background = _param.background, background = _param_background === void 0 ? false : _param_background, map = _param.map, config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_param, [
        "scene",
        "background",
        "map"
    ]);
    var defaultScene = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__["useThree"])({
        "EnvironmentMap.useThree[defaultScene]": function(state) {
            return state.scene;
        }
    }["EnvironmentMap.useThree[defaultScene]"]);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"]({
        "EnvironmentMap.useLayoutEffect": function() {
            if (map) return setEnvProps(background, scene, defaultScene, map, config);
        }
    }["EnvironmentMap.useLayoutEffect"]);
    return null;
}
function EnvironmentCube(_param) {
    var _param_background = _param.background, background = _param_background === void 0 ? false : _param_background, scene = _param.scene, blur = _param.blur, backgroundBlurriness = _param.backgroundBlurriness, backgroundIntensity = _param.backgroundIntensity, backgroundRotation = _param.backgroundRotation, environmentIntensity = _param.environmentIntensity, environmentRotation = _param.environmentRotation, rest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_without_properties$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_param, [
        "background",
        "scene",
        "blur",
        "backgroundBlurriness",
        "backgroundIntensity",
        "backgroundRotation",
        "environmentIntensity",
        "environmentRotation"
    ]);
    var texture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$core$2f$useEnvironment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEnvironment"])(rest);
    var defaultScene = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__["useThree"])({
        "EnvironmentCube.useThree[defaultScene]": function(state) {
            return state.scene;
        }
    }["EnvironmentCube.useThree[defaultScene]"]);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"]({
        "EnvironmentCube.useLayoutEffect": function() {
            return setEnvProps(background, scene, defaultScene, texture, {
                backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,
                backgroundIntensity: backgroundIntensity,
                backgroundRotation: backgroundRotation,
                environmentIntensity: environmentIntensity,
                environmentRotation: environmentRotation
            });
        }
    }["EnvironmentCube.useLayoutEffect"]);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "EnvironmentCube.useEffect": function() {
            return ({
                "EnvironmentCube.useEffect": function() {
                    texture.dispose();
                }
            })["EnvironmentCube.useEffect"];
        }
    }["EnvironmentCube.useEffect"], [
        texture
    ]);
    return null;
}
function EnvironmentPortal(param) {
    var children = param.children, _param_near = param.near, near = _param_near === void 0 ? 0.1 : _param_near, _param_far = param.far, far = _param_far === void 0 ? 1000 : _param_far, _param_resolution = param.resolution, resolution = _param_resolution === void 0 ? 256 : _param_resolution, _param_frames = param.frames, frames = _param_frames === void 0 ? 1 : _param_frames, map = param.map, _param_background = param.background, background = _param_background === void 0 ? false : _param_background, blur = param.blur, backgroundBlurriness = param.backgroundBlurriness, backgroundIntensity = param.backgroundIntensity, backgroundRotation = param.backgroundRotation, environmentIntensity = param.environmentIntensity, environmentRotation = param.environmentRotation, scene = param.scene, files = param.files, path = param.path, _param_preset = param.preset, preset = _param_preset === void 0 ? undefined : _param_preset, extensions = param.extensions;
    var gl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__["useThree"])({
        "EnvironmentPortal.useThree[gl]": function(state) {
            return state.gl;
        }
    }["EnvironmentPortal.useThree[gl]"]);
    var defaultScene = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__C__as__useThree$3e$__["useThree"])({
        "EnvironmentPortal.useThree[defaultScene]": function(state) {
            return state.scene;
        }
    }["EnvironmentPortal.useThree[defaultScene]"]);
    var camera = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    var _React_useState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "EnvironmentPortal._React_useState.useState": function() {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
        }
    }["EnvironmentPortal._React_useState.useState"]), 1), virtualScene = _React_useState[0];
    var fbo = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "EnvironmentPortal.useMemo[fbo]": function() {
            var fbo = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLCubeRenderTarget"](resolution);
            fbo.texture.type = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
            return fbo;
        }
    }["EnvironmentPortal.useMemo[fbo]"], [
        resolution
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "EnvironmentPortal.useEffect": function() {
            return ({
                "EnvironmentPortal.useEffect": function() {
                    fbo.dispose();
                }
            })["EnvironmentPortal.useEffect"];
        }
    }["EnvironmentPortal.useEffect"], [
        fbo
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"]({
        "EnvironmentPortal.useLayoutEffect": function() {
            if (frames === 1) {
                var autoClear = gl.autoClear;
                gl.autoClear = true;
                camera.current.update(gl, virtualScene);
                gl.autoClear = autoClear;
            }
            return setEnvProps(background, scene, defaultScene, fbo.texture, {
                backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,
                backgroundIntensity: backgroundIntensity,
                backgroundRotation: backgroundRotation,
                environmentIntensity: environmentIntensity,
                environmentRotation: environmentRotation
            });
        }
    }["EnvironmentPortal.useLayoutEffect"], [
        children,
        virtualScene,
        fbo.texture,
        scene,
        defaultScene,
        background,
        frames,
        gl
    ]);
    var count = 1;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__D__as__useFrame$3e$__["useFrame"])({
        "EnvironmentPortal.useFrame": function() {
            if (frames === Infinity || count < frames) {
                var autoClear = gl.autoClear;
                gl.autoClear = true;
                camera.current.update(gl, virtualScene);
                gl.autoClear = autoClear;
                count++;
            }
        }
    }["EnvironmentPortal.useFrame"]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__o__as__createPortal$3e$__["createPortal"])(/*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, children, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("cubeCamera", {
        ref: camera,
        args: [
            near,
            far,
            fbo
        ]
    }), files || preset ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](EnvironmentCube, {
        background: true,
        files: files,
        preset: preset,
        path: path,
        extensions: extensions
    }) : map ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](EnvironmentMap, {
        background: true,
        map: map,
        extensions: extensions
    }) : null), virtualScene));
}
function EnvironmentGround(props) {
    var _props$ground, _props$ground2, _scale, _props$ground3;
    var textureDefault = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$drei$2f$core$2f$useEnvironment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEnvironment"])(props);
    var texture = props.map || textureDefault;
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "EnvironmentGround.useMemo": function() {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$react$2d$three$2f$fiber$2f$dist$2f$events$2d$1eccaf1c$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__extend$3e$__["extend"])({
                GroundProjectedEnvImpl: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$objects$2f$GroundProjectedEnv$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GroundProjectedEnv"]
            });
        }
    }["EnvironmentGround.useMemo"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "EnvironmentGround.useEffect": function() {
            return ({
                "EnvironmentGround.useEffect": function() {
                    textureDefault.dispose();
                }
            })["EnvironmentGround.useEffect"];
        }
    }["EnvironmentGround.useEffect"], [
        textureDefault
    ]);
    var args = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "EnvironmentGround.useMemo[args]": function() {
            return [
                texture
            ];
        }
    }["EnvironmentGround.useMemo[args]"], [
        texture
    ]);
    var height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;
    var radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;
    var scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], null, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](EnvironmentMap, (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, props, {
        map: texture
    })), /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"]("groundProjectedEnvImpl", {
        args: args,
        scale: scale,
        height: height,
        radius: radius
    }));
}
function Environment(props) {
    return props.ground ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](EnvironmentGround, props) : props.map ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](EnvironmentMap, props) : props.children ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](EnvironmentPortal, props) : /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](EnvironmentCube, props);
}
;
}),
"[project]/andreas-technology-v2/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_extends
]);
function _extends() {
    return _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", _extends.apply(null, arguments);
}
;
}),
"[project]/andreas-technology-v2/node_modules/three-stdlib/shaders/HorizontalBlurShader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HorizontalBlurShader",
    ()=>HorizontalBlurShader
]);
var HorizontalBlurShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        h: {
            value: 1 / 512
        }
    },
    vertexShader: /* glsl */ "\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  ",
    fragmentShader: /* glsl */ "\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    	vec4 sum = vec4( 0.0 );\n\n    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    	gl_FragColor = sum;\n\n    }\n  "
};
;
 //# sourceMappingURL=HorizontalBlurShader.js.map
}),
"[project]/andreas-technology-v2/node_modules/three-stdlib/shaders/VerticalBlurShader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VerticalBlurShader",
    ()=>VerticalBlurShader
]);
var VerticalBlurShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        v: {
            value: 1 / 512
        }
    },
    vertexShader: /* glsl */ "\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  ",
    fragmentShader: /* glsl */ "\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  "
};
;
 //# sourceMappingURL=VerticalBlurShader.js.map
}),
"[project]/andreas-technology-v2/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "version",
    ()=>version
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
var version = /* @__PURE__ */ function() {
    return parseInt(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REVISION"].replace(/\D+/g, ""));
}();
;
 //# sourceMappingURL=constants.js.map
}),
"[project]/andreas-technology-v2/node_modules/three-stdlib/objects/GroundProjectedEnv.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GroundProjectedEnv",
    ()=>GroundProjectedEnv
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
;
;
;
;
;
;
var isCubeTexture = function(def) {
    return def && def.isCubeTexture;
};
var GroundProjectedEnv = /*#__PURE__*/ function(Mesh) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GroundProjectedEnv, Mesh);
    function GroundProjectedEnv(texture, options) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GroundProjectedEnv);
        var _a, _b;
        var isCubeMap = isCubeTexture(texture);
        var w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;
        var cubeSize = w / 4;
        var _lodMax = Math.floor(Math.log2(cubeSize));
        var _cubeSize = Math.pow(2, _lodMax);
        var width = 3 * Math.max(_cubeSize, 16 * 7);
        var height = 4 * _cubeSize;
        var defines = [
            isCubeMap ? "#define ENVMAP_TYPE_CUBE" : "",
            "#define CUBEUV_TEXEL_WIDTH ".concat(1 / width),
            "#define CUBEUV_TEXEL_HEIGHT ".concat(1 / height),
            "#define CUBEUV_MAX_MIP ".concat(_lodMax, ".0")
        ];
        var vertexShader = /* glsl */ "\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        ";
        var fragmentShader = defines.join("\n") + /* glsl */ "\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <".concat(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment", ">\n        }\n        ");
        var uniforms = {
            map: {
                value: texture
            },
            height: {
                value: (options == null ? void 0 : options.height) || 15
            },
            radius: {
                value: (options == null ? void 0 : options.radius) || 100
            }
        };
        var geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IcosahedronGeometry"](1, 16);
        var material = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            uniforms: uniforms,
            fragmentShader: fragmentShader,
            vertexShader: vertexShader,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"]
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GroundProjectedEnv, [
            geometry,
            material
        ]);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GroundProjectedEnv, [
        {
            key: "radius",
            get: function get() {
                return this.material.uniforms.radius.value;
            },
            set: function set(radius) {
                this.material.uniforms.radius.value = radius;
            }
        },
        {
            key: "height",
            get: function get() {
                return this.material.uniforms.height.value;
            },
            set: function set(height) {
                this.material.uniforms.height.value = height;
            }
        }
    ]);
    return GroundProjectedEnv;
}(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]);
;
 //# sourceMappingURL=GroundProjectedEnv.js.map
}),
"[project]/andreas-technology-v2/node_modules/three-stdlib/loaders/RGBELoader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RGBELoader",
    ()=>RGBELoader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_get_prototype_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
var RGBELoader = /*#__PURE__*/ function(DataTextureLoader) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(RGBELoader, DataTextureLoader);
    function RGBELoader(manager) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, RGBELoader);
        var _this;
        _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, RGBELoader, [
            manager
        ]);
        _this.type = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
        return _this;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(RGBELoader, [
        {
            // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
            key: "parse",
            value: function parse(buffer) {
                var rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function rgbe_error(rgbe_error_code, msg) {
                    switch(rgbe_error_code){
                        case rgbe_read_error:
                            throw new Error("THREE.RGBELoader: Read Error: " + (msg || ""));
                        case rgbe_write_error:
                            throw new Error("THREE.RGBELoader: Write Error: " + (msg || ""));
                        case rgbe_format_error:
                            throw new Error("THREE.RGBELoader: Bad File Format: " + (msg || ""));
                        default:
                        case rgbe_memory_error:
                            throw new Error("THREE.RGBELoader: Memory Error: " + (msg || ""));
                    }
                }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function fgets(buffer2, lineLimit, consume) {
                    var chunkSize = 128;
                    lineLimit = !lineLimit ? 1024 : lineLimit;
                    var p = buffer2.pos, i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
                    while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){
                        s += chunk;
                        len += chunk.length;
                        p += chunkSize;
                        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
                    }
                    if (-1 < i) {
                        if (false !== consume) buffer2.pos += len + i + 1;
                        return s + chunk.slice(0, i);
                    }
                    return false;
                }, RGBE_ReadHeader = function RGBE_ReadHeader(buffer2) {
                    var magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                    var line, match;
                    if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
                        rgbe_error(rgbe_read_error, "no header found");
                    }
                    if (!(match = line.match(magic_token_re))) {
                        rgbe_error(rgbe_format_error, "bad initial token");
                    }
                    header.valid |= RGBE_VALID_PROGRAMTYPE;
                    header.programtype = match[1];
                    header.string += line + "\n";
                    while(true){
                        line = fgets(buffer2);
                        if (false === line) break;
                        header.string += line + "\n";
                        if ("#" === line.charAt(0)) {
                            header.comments += line + "\n";
                            continue;
                        }
                        if (match = line.match(gamma_re)) {
                            header.gamma = parseFloat(match[1]);
                        }
                        if (match = line.match(exposure_re)) {
                            header.exposure = parseFloat(match[1]);
                        }
                        if (match = line.match(format_re)) {
                            header.valid |= RGBE_VALID_FORMAT;
                            header.format = match[1];
                        }
                        if (match = line.match(dimensions_re)) {
                            header.valid |= RGBE_VALID_DIMENSIONS;
                            header.height = parseInt(match[1], 10);
                            header.width = parseInt(match[2], 10);
                        }
                        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
                    }
                    if (!(header.valid & RGBE_VALID_FORMAT)) {
                        rgbe_error(rgbe_format_error, "missing format specifier");
                    }
                    if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
                        rgbe_error(rgbe_format_error, "missing image size specifier");
                    }
                    return header;
                }, RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer2, w2, h2) {
                    var scanline_width = w2;
                    if (// run length encoding is not allowed so read flat
                    scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
                    2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {
                        return new Uint8Array(buffer2);
                    }
                    if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
                        rgbe_error(rgbe_format_error, "wrong scanline width");
                    }
                    var data_rgba = new Uint8Array(4 * w2 * h2);
                    if (!data_rgba.length) {
                        rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
                    }
                    var offset = 0, pos = 0;
                    var ptr_end = 4 * scanline_width;
                    var rgbeStart = new Uint8Array(4);
                    var scanline_buffer = new Uint8Array(ptr_end);
                    var num_scanlines = h2;
                    while(num_scanlines > 0 && pos < buffer2.byteLength){
                        if (pos + 4 > buffer2.byteLength) {
                            rgbe_error(rgbe_read_error);
                        }
                        rgbeStart[0] = buffer2[pos++];
                        rgbeStart[1] = buffer2[pos++];
                        rgbeStart[2] = buffer2[pos++];
                        rgbeStart[3] = buffer2[pos++];
                        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
                            rgbe_error(rgbe_format_error, "bad rgbe scanline format");
                        }
                        var ptr = 0, count = void 0;
                        while(ptr < ptr_end && pos < buffer2.byteLength){
                            count = buffer2[pos++];
                            var isEncodedRun = count > 128;
                            if (isEncodedRun) count -= 128;
                            if (0 === count || ptr + count > ptr_end) {
                                rgbe_error(rgbe_format_error, "bad scanline data");
                            }
                            if (isEncodedRun) {
                                var byteValue = buffer2[pos++];
                                for(var i = 0; i < count; i++){
                                    scanline_buffer[ptr++] = byteValue;
                                }
                            } else {
                                scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
                                ptr += count;
                                pos += count;
                            }
                        }
                        var l = scanline_width;
                        for(var i1 = 0; i1 < l; i1++){
                            var off = 0;
                            data_rgba[offset] = scanline_buffer[i1 + off];
                            off += scanline_width;
                            data_rgba[offset + 1] = scanline_buffer[i1 + off];
                            off += scanline_width;
                            data_rgba[offset + 2] = scanline_buffer[i1 + off];
                            off += scanline_width;
                            data_rgba[offset + 3] = scanline_buffer[i1 + off];
                            offset += 4;
                        }
                        num_scanlines--;
                    }
                    return data_rgba;
                };
                var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {
                    var e = sourceArray[sourceOffset + 3];
                    var scale = Math.pow(2, e - 128) / 255;
                    destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
                    destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
                    destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
                    destArray[destOffset + 3] = 1;
                };
                var RGBEByteToRGBHalf = function RGBEByteToRGBHalf(sourceArray, sourceOffset, destArray, destOffset) {
                    var e = sourceArray[sourceOffset + 3];
                    var scale = Math.pow(2, e - 128) / 255;
                    destArray[destOffset + 0] = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
                    destArray[destOffset + 1] = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
                    destArray[destOffset + 2] = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
                    destArray[destOffset + 3] = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(1);
                };
                var byteArray = new Uint8Array(buffer);
                byteArray.pos = 0;
                var rgbe_header_info = RGBE_ReadHeader(byteArray);
                var w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
                var data, type;
                var numElements;
                switch(this.type){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                        numElements = image_rgba_data.length / 4;
                        var floatArray = new Float32Array(numElements * 4);
                        for(var j = 0; j < numElements; j++){
                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
                        }
                        data = floatArray;
                        type = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"];
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                        numElements = image_rgba_data.length / 4;
                        var halfArray = new Uint16Array(numElements * 4);
                        for(var j1 = 0; j1 < numElements; j1++){
                            RGBEByteToRGBHalf(image_rgba_data, j1 * 4, halfArray, j1 * 4);
                        }
                        data = halfArray;
                        type = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
                        break;
                    default:
                        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
                }
                return {
                    width: w,
                    height: h,
                    data: data,
                    header: rgbe_header_info.string,
                    gamma: rgbe_header_info.gamma,
                    exposure: rgbe_header_info.exposure,
                    type: type
                };
            }
        },
        {
            key: "setDataType",
            value: function setDataType(value) {
                this.type = value;
                return this;
            }
        },
        {
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
                function onLoadCallback(texture, texData) {
                    switch(texture.type){
                        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                            if ("colorSpace" in texture) texture.colorSpace = "srgb-linear";
                            else texture.encoding = 3e3;
                            texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                            texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                            texture.generateMipmaps = false;
                            texture.flipY = true;
                            break;
                    }
                    if (onLoad) onLoad(texture, texData);
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(RGBELoader.prototype), "load", this).call(this, url, onLoadCallback, onProgress, onError);
            }
        }
    ]);
    return RGBELoader;
}(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTextureLoader"]);
;
 //# sourceMappingURL=RGBELoader.js.map
}),
"[project]/andreas-technology-v2/node_modules/three-stdlib/loaders/EXRLoader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EXRLoader",
    ()=>EXRLoader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_get_prototype_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three-stdlib/node_modules/fflate/esm/browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three-stdlib/_polyfill/constants.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
var hasColorSpace = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"] >= 152;
var EXRLoader = /*#__PURE__*/ function(DataTextureLoader) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(EXRLoader, DataTextureLoader);
    function EXRLoader(manager) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, EXRLoader);
        var _this;
        _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, EXRLoader, [
            manager
        ]);
        _this.type = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"];
        return _this;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(EXRLoader, [
        {
            key: "parse",
            value: function parse(buffer) {
                var USHORT_RANGE = 1 << 16;
                var BITMAP_SIZE = USHORT_RANGE >> 3;
                var HUF_ENCBITS = 16;
                var HUF_DECBITS = 14;
                var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;
                var HUF_DECSIZE = 1 << HUF_DECBITS;
                var HUF_DECMASK = HUF_DECSIZE - 1;
                var NBITS = 16;
                var A_OFFSET = 1 << NBITS - 1;
                var MOD_MASK = (1 << NBITS) - 1;
                var SHORT_ZEROCODE_RUN = 59;
                var LONG_ZEROCODE_RUN = 63;
                var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
                var ULONG_SIZE = 8;
                var FLOAT32_SIZE = 4;
                var INT32_SIZE = 4;
                var INT16_SIZE = 2;
                var INT8_SIZE = 1;
                var STATIC_HUFFMAN = 0;
                var DEFLATE = 1;
                var UNKNOWN = 0;
                var LOSSY_DCT = 1;
                var RLE = 2;
                var logBase = Math.pow(2.7182818, 2.2);
                function reverseLutFromBitmap(bitmap, lut) {
                    var k = 0;
                    for(var i = 0; i < USHORT_RANGE; ++i){
                        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {
                            lut[k++] = i;
                        }
                    }
                    var n = k - 1;
                    while(k < USHORT_RANGE)lut[k++] = 0;
                    return n;
                }
                function hufClearDecTable(hdec) {
                    for(var i = 0; i < HUF_DECSIZE; i++){
                        hdec[i] = {};
                        hdec[i].len = 0;
                        hdec[i].lit = 0;
                        hdec[i].p = null;
                    }
                }
                var getBitsReturn = {
                    l: 0,
                    c: 0,
                    lc: 0
                };
                function getBits(nBits, c, lc, uInt8Array2, inOffset) {
                    while(lc < nBits){
                        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
                        lc += 8;
                    }
                    lc -= nBits;
                    getBitsReturn.l = c >> lc & (1 << nBits) - 1;
                    getBitsReturn.c = c;
                    getBitsReturn.lc = lc;
                }
                var hufTableBuffer = new Array(59);
                function hufCanonicalCodeTable(hcode) {
                    for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;
                    for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;
                    var c = 0;
                    for(var i = 58; i > 0; --i){
                        var nc = c + hufTableBuffer[i] >> 1;
                        hufTableBuffer[i] = c;
                        c = nc;
                    }
                    for(var i = 0; i < HUF_ENCSIZE; ++i){
                        var l = hcode[i];
                        if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;
                    }
                }
                function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {
                    var p = inOffset;
                    var c = 0;
                    var lc = 0;
                    for(; im <= iM; im++){
                        if (p.value - inOffset.value > ni) return false;
                        getBits(6, c, lc, uInt8Array2, p);
                        var l = getBitsReturn.l;
                        c = getBitsReturn.c;
                        lc = getBitsReturn.lc;
                        hcode[im] = l;
                        if (l == LONG_ZEROCODE_RUN) {
                            if (p.value - inOffset.value > ni) {
                                throw "Something wrong with hufUnpackEncTable";
                            }
                            getBits(8, c, lc, uInt8Array2, p);
                            var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
                            c = getBitsReturn.c;
                            lc = getBitsReturn.lc;
                            if (im + zerun > iM + 1) {
                                throw "Something wrong with hufUnpackEncTable";
                            }
                            while(zerun--)hcode[im++] = 0;
                            im--;
                        } else if (l >= SHORT_ZEROCODE_RUN) {
                            var zerun = l - SHORT_ZEROCODE_RUN + 2;
                            if (im + zerun > iM + 1) {
                                throw "Something wrong with hufUnpackEncTable";
                            }
                            while(zerun--)hcode[im++] = 0;
                            im--;
                        }
                    }
                    hufCanonicalCodeTable(hcode);
                }
                function hufLength(code) {
                    return code & 63;
                }
                function hufCode(code) {
                    return code >> 6;
                }
                function hufBuildDecTable(hcode, im, iM, hdecod) {
                    for(; im <= iM; im++){
                        var c = hufCode(hcode[im]);
                        var l = hufLength(hcode[im]);
                        if (c >> l) {
                            throw "Invalid table entry";
                        }
                        if (l > HUF_DECBITS) {
                            var pl = hdecod[c >> l - HUF_DECBITS];
                            if (pl.len) {
                                throw "Invalid table entry";
                            }
                            pl.lit++;
                            if (pl.p) {
                                var p = pl.p;
                                pl.p = new Array(pl.lit);
                                for(var i = 0; i < pl.lit - 1; ++i){
                                    pl.p[i] = p[i];
                                }
                            } else {
                                pl.p = new Array(1);
                            }
                            pl.p[pl.lit - 1] = im;
                        } else if (l) {
                            var plOffset = 0;
                            for(var i = 1 << HUF_DECBITS - l; i > 0; i--){
                                var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];
                                if (pl.len || pl.p) {
                                    throw "Invalid table entry";
                                }
                                pl.len = l;
                                pl.lit = im;
                                plOffset++;
                            }
                        }
                    }
                    return true;
                }
                var getCharReturn = {
                    c: 0,
                    lc: 0
                };
                function getChar(c, lc, uInt8Array2, inOffset) {
                    c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
                    lc += 8;
                    getCharReturn.c = c;
                    getCharReturn.lc = lc;
                }
                var getCodeReturn = {
                    c: 0,
                    lc: 0
                };
                function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {
                    if (po == rlc) {
                        if (lc < 8) {
                            getChar(c, lc, uInt8Array2, inOffset);
                            c = getCharReturn.c;
                            lc = getCharReturn.lc;
                        }
                        lc -= 8;
                        var cs = c >> lc;
                        var cs = new Uint8Array([
                            cs
                        ])[0];
                        if (outBufferOffset.value + cs > outBufferEndOffset) {
                            return false;
                        }
                        var s = outBuffer[outBufferOffset.value - 1];
                        while(cs-- > 0){
                            outBuffer[outBufferOffset.value++] = s;
                        }
                    } else if (outBufferOffset.value < outBufferEndOffset) {
                        outBuffer[outBufferOffset.value++] = po;
                    } else {
                        return false;
                    }
                    getCodeReturn.c = c;
                    getCodeReturn.lc = lc;
                }
                function UInt16(value) {
                    return value & 65535;
                }
                function Int16(value) {
                    var ref = UInt16(value);
                    return ref > 32767 ? ref - 65536 : ref;
                }
                var wdec14Return = {
                    a: 0,
                    b: 0
                };
                function wdec14(l, h) {
                    var ls = Int16(l);
                    var hs = Int16(h);
                    var hi = hs;
                    var ai = ls + (hi & 1) + (hi >> 1);
                    var as = ai;
                    var bs = ai - hi;
                    wdec14Return.a = as;
                    wdec14Return.b = bs;
                }
                function wdec16(l, h) {
                    var m = UInt16(l);
                    var d = UInt16(h);
                    var bb = m - (d >> 1) & MOD_MASK;
                    var aa = d + bb - A_OFFSET & MOD_MASK;
                    wdec14Return.a = aa;
                    wdec14Return.b = bb;
                }
                function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {
                    var w14 = mx < 1 << 14;
                    var n = nx > ny ? ny : nx;
                    var p = 1;
                    var p2;
                    while(p <= n)p <<= 1;
                    p >>= 1;
                    p2 = p;
                    p >>= 1;
                    while(p >= 1){
                        var py = 0;
                        var ey = py + oy * (ny - p2);
                        var oy1 = oy * p;
                        var oy2 = oy * p2;
                        var ox1 = ox * p;
                        var ox2 = ox * p2;
                        var i00, i01, i10, i11;
                        for(; py <= ey; py += oy2){
                            var px = py;
                            var ex = py + ox * (nx - p2);
                            for(; px <= ex; px += ox2){
                                var p01 = px + ox1;
                                var p10 = px + oy1;
                                var p11 = p10 + ox1;
                                if (w14) {
                                    wdec14(buffer2[px + j], buffer2[p10 + j]);
                                    i00 = wdec14Return.a;
                                    i10 = wdec14Return.b;
                                    wdec14(buffer2[p01 + j], buffer2[p11 + j]);
                                    i01 = wdec14Return.a;
                                    i11 = wdec14Return.b;
                                    wdec14(i00, i01);
                                    buffer2[px + j] = wdec14Return.a;
                                    buffer2[p01 + j] = wdec14Return.b;
                                    wdec14(i10, i11);
                                    buffer2[p10 + j] = wdec14Return.a;
                                    buffer2[p11 + j] = wdec14Return.b;
                                } else {
                                    wdec16(buffer2[px + j], buffer2[p10 + j]);
                                    i00 = wdec14Return.a;
                                    i10 = wdec14Return.b;
                                    wdec16(buffer2[p01 + j], buffer2[p11 + j]);
                                    i01 = wdec14Return.a;
                                    i11 = wdec14Return.b;
                                    wdec16(i00, i01);
                                    buffer2[px + j] = wdec14Return.a;
                                    buffer2[p01 + j] = wdec14Return.b;
                                    wdec16(i10, i11);
                                    buffer2[p10 + j] = wdec14Return.a;
                                    buffer2[p11 + j] = wdec14Return.b;
                                }
                            }
                            if (nx & p) {
                                var p10 = px + oy1;
                                if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);
                                else wdec16(buffer2[px + j], buffer2[p10 + j]);
                                i00 = wdec14Return.a;
                                buffer2[p10 + j] = wdec14Return.b;
                                buffer2[px + j] = i00;
                            }
                        }
                        if (ny & p) {
                            var px = py;
                            var ex = py + ox * (nx - p2);
                            for(; px <= ex; px += ox2){
                                var p01 = px + ox1;
                                if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);
                                else wdec16(buffer2[px + j], buffer2[p01 + j]);
                                i00 = wdec14Return.a;
                                buffer2[p01 + j] = wdec14Return.b;
                                buffer2[px + j] = i00;
                            }
                        }
                        p2 = p;
                        p >>= 1;
                    }
                    return py;
                }
                function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {
                    var c = 0;
                    var lc = 0;
                    var outBufferEndOffset = no;
                    var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);
                    while(inOffset.value < inOffsetEnd){
                        getChar(c, lc, uInt8Array2, inOffset);
                        c = getCharReturn.c;
                        lc = getCharReturn.lc;
                        while(lc >= HUF_DECBITS){
                            var index = c >> lc - HUF_DECBITS & HUF_DECMASK;
                            var pl = decodingTable[index];
                            if (pl.len) {
                                lc -= pl.len;
                                getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                                c = getCodeReturn.c;
                                lc = getCodeReturn.lc;
                            } else {
                                if (!pl.p) {
                                    throw "hufDecode issues";
                                }
                                var j;
                                for(j = 0; j < pl.lit; j++){
                                    var l = hufLength(encodingTable[pl.p[j]]);
                                    while(lc < l && inOffset.value < inOffsetEnd){
                                        getChar(c, lc, uInt8Array2, inOffset);
                                        c = getCharReturn.c;
                                        lc = getCharReturn.lc;
                                    }
                                    if (lc >= l) {
                                        if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {
                                            lc -= l;
                                            getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                                            c = getCodeReturn.c;
                                            lc = getCodeReturn.lc;
                                            break;
                                        }
                                    }
                                }
                                if (j == pl.lit) {
                                    throw "hufDecode issues";
                                }
                            }
                        }
                    }
                    var i = 8 - ni & 7;
                    c >>= i;
                    lc -= i;
                    while(lc > 0){
                        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];
                        if (pl.len) {
                            lc -= pl.len;
                            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                            c = getCodeReturn.c;
                            lc = getCodeReturn.lc;
                        } else {
                            throw "hufDecode issues";
                        }
                    }
                    return true;
                }
                function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {
                    var outOffset = {
                        value: 0
                    };
                    var initialInOffset = inOffset.value;
                    var im = parseUint32(inDataView, inOffset);
                    var iM = parseUint32(inDataView, inOffset);
                    inOffset.value += 4;
                    var nBits = parseUint32(inDataView, inOffset);
                    inOffset.value += 4;
                    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {
                        throw "Something wrong with HUF_ENCSIZE";
                    }
                    var freq = new Array(HUF_ENCSIZE);
                    var hdec = new Array(HUF_DECSIZE);
                    hufClearDecTable(hdec);
                    var ni = nCompressed - (inOffset.value - initialInOffset);
                    hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);
                    if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {
                        throw "Something wrong with hufUncompress";
                    }
                    hufBuildDecTable(freq, im, iM, hdec);
                    hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);
                }
                function applyLut(lut, data, nData) {
                    for(var i = 0; i < nData; ++i){
                        data[i] = lut[data[i]];
                    }
                }
                function predictor(source) {
                    for(var t = 1; t < source.length; t++){
                        var d = source[t - 1] + source[t] - 128;
                        source[t] = d;
                    }
                }
                function interleaveScalar(source, out) {
                    var t1 = 0;
                    var t2 = Math.floor((source.length + 1) / 2);
                    var s = 0;
                    var stop = source.length - 1;
                    while(true){
                        if (s > stop) break;
                        out[s++] = source[t1++];
                        if (s > stop) break;
                        out[s++] = source[t2++];
                    }
                }
                function decodeRunLength(source) {
                    var size = source.byteLength;
                    var out = new Array();
                    var p = 0;
                    var reader = new DataView(source);
                    while(size > 0){
                        var l = reader.getInt8(p++);
                        if (l < 0) {
                            var count = -l;
                            size -= count + 1;
                            for(var i = 0; i < count; i++){
                                out.push(reader.getUint8(p++));
                            }
                        } else {
                            var count = l;
                            size -= 2;
                            var value = reader.getUint8(p++);
                            for(var i = 0; i < count + 1; i++){
                                out.push(value);
                            }
                        }
                    }
                    return out;
                }
                function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {
                    var dataView = new DataView(outBuffer.buffer);
                    var width = channelData[cscSet.idx[0]].width;
                    var height = channelData[cscSet.idx[0]].height;
                    var numComp = 3;
                    var numFullBlocksX = Math.floor(width / 8);
                    var numBlocksX = Math.ceil(width / 8);
                    var numBlocksY = Math.ceil(height / 8);
                    var leftoverX = width - (numBlocksX - 1) * 8;
                    var leftoverY = height - (numBlocksY - 1) * 8;
                    var currAcComp = {
                        value: 0
                    };
                    var currDcComp = new Array(numComp);
                    var dctData = new Array(numComp);
                    var halfZigBlock = new Array(numComp);
                    var rowBlock = new Array(numComp);
                    var rowOffsets = new Array(numComp);
                    for(var comp2 = 0; comp2 < numComp; ++comp2){
                        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];
                        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;
                        dctData[comp2] = new Float32Array(64);
                        halfZigBlock[comp2] = new Uint16Array(64);
                        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);
                    }
                    for(var blocky = 0; blocky < numBlocksY; ++blocky){
                        var maxY = 8;
                        if (blocky == numBlocksY - 1) maxY = leftoverY;
                        var maxX = 8;
                        for(var blockx = 0; blockx < numBlocksX; ++blockx){
                            if (blockx == numBlocksX - 1) maxX = leftoverX;
                            for(var comp21 = 0; comp21 < numComp; ++comp21){
                                halfZigBlock[comp21].fill(0);
                                halfZigBlock[comp21][0] = dcBuffer[currDcComp[comp21]++];
                                unRleAC(currAcComp, acBuffer, halfZigBlock[comp21]);
                                unZigZag(halfZigBlock[comp21], dctData[comp21]);
                                dctInverse(dctData[comp21]);
                            }
                            {
                                csc709Inverse(dctData);
                            }
                            for(var comp22 = 0; comp22 < numComp; ++comp22){
                                convertToHalf(dctData[comp22], rowBlock[comp22], blockx * 64);
                            }
                        }
                        var offset2 = 0;
                        for(var comp23 = 0; comp23 < numComp; ++comp23){
                            var type2 = channelData[cscSet.idx[comp23]].type;
                            for(var y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){
                                offset2 = rowOffsets[comp23][y2];
                                for(var blockx1 = 0; blockx1 < numFullBlocksX; ++blockx1){
                                    var src = blockx1 * 64 + (y2 & 7) * 8;
                                    dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp23][src + 0], true);
                                    dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp23][src + 1], true);
                                    dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp23][src + 2], true);
                                    dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp23][src + 3], true);
                                    dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp23][src + 4], true);
                                    dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp23][src + 5], true);
                                    dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp23][src + 6], true);
                                    dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp23][src + 7], true);
                                    offset2 += 8 * INT16_SIZE * type2;
                                }
                            }
                            if (numFullBlocksX != numBlocksX) {
                                for(var y21 = 8 * blocky; y21 < 8 * blocky + maxY; ++y21){
                                    var offset3 = rowOffsets[comp23][y21] + 8 * numFullBlocksX * INT16_SIZE * type2;
                                    var src1 = numFullBlocksX * 64 + (y21 & 7) * 8;
                                    for(var x2 = 0; x2 < maxX; ++x2){
                                        dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp23][src1 + x2], true);
                                    }
                                }
                            }
                        }
                    }
                    var halfRow = new Uint16Array(width);
                    var dataView = new DataView(outBuffer.buffer);
                    for(var comp = 0; comp < numComp; ++comp){
                        channelData[cscSet.idx[comp]].decoded = true;
                        var type = channelData[cscSet.idx[comp]].type;
                        if (channelData[comp].type != 2) continue;
                        for(var y = 0; y < height; ++y){
                            var offset21 = rowOffsets[comp][y];
                            for(var x = 0; x < width; ++x){
                                halfRow[x] = dataView.getUint16(offset21 + x * INT16_SIZE * type, true);
                            }
                            for(var x = 0; x < width; ++x){
                                dataView.setFloat32(offset21 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);
                            }
                        }
                    }
                }
                function unRleAC(currAcComp, acBuffer, halfZigBlock) {
                    var acValue;
                    var dctComp = 1;
                    while(dctComp < 64){
                        acValue = acBuffer[currAcComp.value];
                        if (acValue == 65280) {
                            dctComp = 64;
                        } else if (acValue >> 8 == 255) {
                            dctComp += acValue & 255;
                        } else {
                            halfZigBlock[dctComp] = acValue;
                            dctComp++;
                        }
                        currAcComp.value++;
                    }
                }
                function unZigZag(src, dst) {
                    dst[0] = decodeFloat16(src[0]);
                    dst[1] = decodeFloat16(src[1]);
                    dst[2] = decodeFloat16(src[5]);
                    dst[3] = decodeFloat16(src[6]);
                    dst[4] = decodeFloat16(src[14]);
                    dst[5] = decodeFloat16(src[15]);
                    dst[6] = decodeFloat16(src[27]);
                    dst[7] = decodeFloat16(src[28]);
                    dst[8] = decodeFloat16(src[2]);
                    dst[9] = decodeFloat16(src[4]);
                    dst[10] = decodeFloat16(src[7]);
                    dst[11] = decodeFloat16(src[13]);
                    dst[12] = decodeFloat16(src[16]);
                    dst[13] = decodeFloat16(src[26]);
                    dst[14] = decodeFloat16(src[29]);
                    dst[15] = decodeFloat16(src[42]);
                    dst[16] = decodeFloat16(src[3]);
                    dst[17] = decodeFloat16(src[8]);
                    dst[18] = decodeFloat16(src[12]);
                    dst[19] = decodeFloat16(src[17]);
                    dst[20] = decodeFloat16(src[25]);
                    dst[21] = decodeFloat16(src[30]);
                    dst[22] = decodeFloat16(src[41]);
                    dst[23] = decodeFloat16(src[43]);
                    dst[24] = decodeFloat16(src[9]);
                    dst[25] = decodeFloat16(src[11]);
                    dst[26] = decodeFloat16(src[18]);
                    dst[27] = decodeFloat16(src[24]);
                    dst[28] = decodeFloat16(src[31]);
                    dst[29] = decodeFloat16(src[40]);
                    dst[30] = decodeFloat16(src[44]);
                    dst[31] = decodeFloat16(src[53]);
                    dst[32] = decodeFloat16(src[10]);
                    dst[33] = decodeFloat16(src[19]);
                    dst[34] = decodeFloat16(src[23]);
                    dst[35] = decodeFloat16(src[32]);
                    dst[36] = decodeFloat16(src[39]);
                    dst[37] = decodeFloat16(src[45]);
                    dst[38] = decodeFloat16(src[52]);
                    dst[39] = decodeFloat16(src[54]);
                    dst[40] = decodeFloat16(src[20]);
                    dst[41] = decodeFloat16(src[22]);
                    dst[42] = decodeFloat16(src[33]);
                    dst[43] = decodeFloat16(src[38]);
                    dst[44] = decodeFloat16(src[46]);
                    dst[45] = decodeFloat16(src[51]);
                    dst[46] = decodeFloat16(src[55]);
                    dst[47] = decodeFloat16(src[60]);
                    dst[48] = decodeFloat16(src[21]);
                    dst[49] = decodeFloat16(src[34]);
                    dst[50] = decodeFloat16(src[37]);
                    dst[51] = decodeFloat16(src[47]);
                    dst[52] = decodeFloat16(src[50]);
                    dst[53] = decodeFloat16(src[56]);
                    dst[54] = decodeFloat16(src[59]);
                    dst[55] = decodeFloat16(src[61]);
                    dst[56] = decodeFloat16(src[35]);
                    dst[57] = decodeFloat16(src[36]);
                    dst[58] = decodeFloat16(src[48]);
                    dst[59] = decodeFloat16(src[49]);
                    dst[60] = decodeFloat16(src[57]);
                    dst[61] = decodeFloat16(src[58]);
                    dst[62] = decodeFloat16(src[62]);
                    dst[63] = decodeFloat16(src[63]);
                }
                function dctInverse(data) {
                    var a = 0.5 * Math.cos(3.14159 / 4);
                    var b = 0.5 * Math.cos(3.14159 / 16);
                    var c = 0.5 * Math.cos(3.14159 / 8);
                    var d = 0.5 * Math.cos(3 * 3.14159 / 16);
                    var e = 0.5 * Math.cos(5 * 3.14159 / 16);
                    var f = 0.5 * Math.cos(3 * 3.14159 / 8);
                    var g = 0.5 * Math.cos(7 * 3.14159 / 16);
                    var alpha = new Array(4);
                    var beta = new Array(4);
                    var theta = new Array(4);
                    var gamma = new Array(4);
                    for(var row = 0; row < 8; ++row){
                        var rowPtr = row * 8;
                        alpha[0] = c * data[rowPtr + 2];
                        alpha[1] = f * data[rowPtr + 2];
                        alpha[2] = c * data[rowPtr + 6];
                        alpha[3] = f * data[rowPtr + 6];
                        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];
                        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];
                        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];
                        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];
                        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);
                        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);
                        theta[1] = alpha[0] + alpha[3];
                        theta[2] = alpha[1] - alpha[2];
                        gamma[0] = theta[0] + theta[1];
                        gamma[1] = theta[3] + theta[2];
                        gamma[2] = theta[3] - theta[2];
                        gamma[3] = theta[0] - theta[1];
                        data[rowPtr + 0] = gamma[0] + beta[0];
                        data[rowPtr + 1] = gamma[1] + beta[1];
                        data[rowPtr + 2] = gamma[2] + beta[2];
                        data[rowPtr + 3] = gamma[3] + beta[3];
                        data[rowPtr + 4] = gamma[3] - beta[3];
                        data[rowPtr + 5] = gamma[2] - beta[2];
                        data[rowPtr + 6] = gamma[1] - beta[1];
                        data[rowPtr + 7] = gamma[0] - beta[0];
                    }
                    for(var column = 0; column < 8; ++column){
                        alpha[0] = c * data[16 + column];
                        alpha[1] = f * data[16 + column];
                        alpha[2] = c * data[48 + column];
                        alpha[3] = f * data[48 + column];
                        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];
                        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];
                        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];
                        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];
                        theta[0] = a * (data[column] + data[32 + column]);
                        theta[3] = a * (data[column] - data[32 + column]);
                        theta[1] = alpha[0] + alpha[3];
                        theta[2] = alpha[1] - alpha[2];
                        gamma[0] = theta[0] + theta[1];
                        gamma[1] = theta[3] + theta[2];
                        gamma[2] = theta[3] - theta[2];
                        gamma[3] = theta[0] - theta[1];
                        data[0 + column] = gamma[0] + beta[0];
                        data[8 + column] = gamma[1] + beta[1];
                        data[16 + column] = gamma[2] + beta[2];
                        data[24 + column] = gamma[3] + beta[3];
                        data[32 + column] = gamma[3] - beta[3];
                        data[40 + column] = gamma[2] - beta[2];
                        data[48 + column] = gamma[1] - beta[1];
                        data[56 + column] = gamma[0] - beta[0];
                    }
                }
                function csc709Inverse(data) {
                    for(var i = 0; i < 64; ++i){
                        var y = data[0][i];
                        var cb = data[1][i];
                        var cr = data[2][i];
                        data[0][i] = y + 1.5747 * cr;
                        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;
                        data[2][i] = y + 1.8556 * cb;
                    }
                }
                function convertToHalf(src, dst, idx) {
                    for(var i = 0; i < 64; ++i){
                        dst[idx + i] = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(toLinear(src[i]));
                    }
                }
                function toLinear(_float) {
                    if (_float <= 1) {
                        return Math.sign(_float) * Math.pow(Math.abs(_float), 2.2);
                    } else {
                        return Math.sign(_float) * Math.pow(logBase, Math.abs(_float) - 1);
                    }
                }
                function uncompressRAW(info) {
                    return new DataView(info.array.buffer, info.offset.value, info.size);
                }
                function uncompressRLE(info) {
                    var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);
                    var rawBuffer = new Uint8Array(decodeRunLength(compressed));
                    var tmpBuffer = new Uint8Array(rawBuffer.length);
                    predictor(rawBuffer);
                    interleaveScalar(rawBuffer, tmpBuffer);
                    return new DataView(tmpBuffer.buffer);
                }
                function uncompressZIP(info) {
                    var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
                    var rawBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
                    var tmpBuffer = new Uint8Array(rawBuffer.length);
                    predictor(rawBuffer);
                    interleaveScalar(rawBuffer, tmpBuffer);
                    return new DataView(tmpBuffer.buffer);
                }
                function uncompressPIZ(info) {
                    var inDataView = info.viewer;
                    var inOffset = {
                        value: info.offset.value
                    };
                    var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));
                    var bitmap = new Uint8Array(BITMAP_SIZE);
                    var outBufferEnd = 0;
                    var pizChannelData = new Array(info.channels);
                    for(var i = 0; i < info.channels; i++){
                        pizChannelData[i] = {};
                        pizChannelData[i]["start"] = outBufferEnd;
                        pizChannelData[i]["end"] = pizChannelData[i]["start"];
                        pizChannelData[i]["nx"] = info.width;
                        pizChannelData[i]["ny"] = info.lines;
                        pizChannelData[i]["size"] = info.type;
                        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;
                    }
                    var minNonZero = parseUint16(inDataView, inOffset);
                    var maxNonZero = parseUint16(inDataView, inOffset);
                    if (maxNonZero >= BITMAP_SIZE) {
                        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
                    }
                    if (minNonZero <= maxNonZero) {
                        for(var i = 0; i < maxNonZero - minNonZero + 1; i++){
                            bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);
                        }
                    }
                    var lut = new Uint16Array(USHORT_RANGE);
                    var maxValue = reverseLutFromBitmap(bitmap, lut);
                    var length = parseUint32(inDataView, inOffset);
                    hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);
                    for(var i = 0; i < info.channels; ++i){
                        var cd = pizChannelData[i];
                        for(var j = 0; j < pizChannelData[i].size; ++j){
                            wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);
                        }
                    }
                    applyLut(lut, outBuffer, outBufferEnd);
                    var tmpOffset2 = 0;
                    var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);
                    for(var y = 0; y < info.lines; y++){
                        for(var c = 0; c < info.channels; c++){
                            var cd = pizChannelData[c];
                            var n = cd.nx * cd.size;
                            var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);
                            tmpBuffer.set(cp, tmpOffset2);
                            tmpOffset2 += n * INT16_SIZE;
                            cd.end += n;
                        }
                    }
                    return new DataView(tmpBuffer.buffer);
                }
                function uncompressPXR(info) {
                    var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
                    var rawBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
                    var sz = info.lines * info.channels * info.width;
                    var tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);
                    var tmpBufferEnd = 0;
                    var writePtr = 0;
                    var ptr = new Array(4);
                    for(var y = 0; y < info.lines; y++){
                        for(var c = 0; c < info.channels; c++){
                            var pixel = 0;
                            switch(info.type){
                                case 1:
                                    ptr[0] = tmpBufferEnd;
                                    ptr[1] = ptr[0] + info.width;
                                    tmpBufferEnd = ptr[1] + info.width;
                                    for(var j = 0; j < info.width; ++j){
                                        var diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];
                                        pixel += diff;
                                        tmpBuffer[writePtr] = pixel;
                                        writePtr++;
                                    }
                                    break;
                                case 2:
                                    ptr[0] = tmpBufferEnd;
                                    ptr[1] = ptr[0] + info.width;
                                    ptr[2] = ptr[1] + info.width;
                                    tmpBufferEnd = ptr[2] + info.width;
                                    for(var j1 = 0; j1 < info.width; ++j1){
                                        var diff1 = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;
                                        pixel += diff1;
                                        tmpBuffer[writePtr] = pixel;
                                        writePtr++;
                                    }
                                    break;
                            }
                        }
                    }
                    return new DataView(tmpBuffer.buffer);
                }
                function uncompressDWA(info) {
                    var inDataView = info.viewer;
                    var inOffset = {
                        value: info.offset.value
                    };
                    var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));
                    var dwaHeader = {
                        version: parseInt64(inDataView, inOffset),
                        unknownUncompressedSize: parseInt64(inDataView, inOffset),
                        unknownCompressedSize: parseInt64(inDataView, inOffset),
                        acCompressedSize: parseInt64(inDataView, inOffset),
                        dcCompressedSize: parseInt64(inDataView, inOffset),
                        rleCompressedSize: parseInt64(inDataView, inOffset),
                        rleUncompressedSize: parseInt64(inDataView, inOffset),
                        rleRawSize: parseInt64(inDataView, inOffset),
                        totalAcUncompressedCount: parseInt64(inDataView, inOffset),
                        totalDcUncompressedCount: parseInt64(inDataView, inOffset),
                        acCompression: parseInt64(inDataView, inOffset)
                    };
                    if (dwaHeader.version < 2) {
                        throw "EXRLoader.parse: " + EXRHeader.compression + " version " + dwaHeader.version + " is unsupported";
                    }
                    var channelRules = new Array();
                    var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;
                    while(ruleSize > 0){
                        var name = parseNullTerminatedString(inDataView.buffer, inOffset);
                        var value = parseUint8(inDataView, inOffset);
                        var compression = value >> 2 & 3;
                        var csc = (value >> 4) - 1;
                        var index = new Int8Array([
                            csc
                        ])[0];
                        var type = parseUint8(inDataView, inOffset);
                        channelRules.push({
                            name: name,
                            index: index,
                            type: type,
                            compression: compression
                        });
                        ruleSize -= name.length + 3;
                    }
                    var channels = EXRHeader.channels;
                    var channelData = new Array(info.channels);
                    for(var i = 0; i < info.channels; ++i){
                        var cd = channelData[i] = {};
                        var channel = channels[i];
                        cd.name = channel.name;
                        cd.compression = UNKNOWN;
                        cd.decoded = false;
                        cd.type = channel.pixelType;
                        cd.pLinear = channel.pLinear;
                        cd.width = info.width;
                        cd.height = info.lines;
                    }
                    var cscSet = {
                        idx: new Array(3)
                    };
                    for(var offset2 = 0; offset2 < info.channels; ++offset2){
                        var cd = channelData[offset2];
                        for(var i = 0; i < channelRules.length; ++i){
                            var rule = channelRules[i];
                            if (cd.name == rule.name) {
                                cd.compression = rule.compression;
                                if (rule.index >= 0) {
                                    cscSet.idx[rule.index] = offset2;
                                }
                                cd.offset = offset2;
                            }
                        }
                    }
                    if (dwaHeader.acCompressedSize > 0) {
                        switch(dwaHeader.acCompression){
                            case STATIC_HUFFMAN:
                                var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);
                                hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);
                                break;
                            case DEFLATE:
                                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);
                                var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
                                var acBuffer = new Uint16Array(data.buffer);
                                inOffset.value += dwaHeader.totalAcUncompressedCount;
                                break;
                        }
                    }
                    if (dwaHeader.dcCompressedSize > 0) {
                        var zlibInfo = {
                            array: info.array,
                            offset: inOffset,
                            size: dwaHeader.dcCompressedSize
                        };
                        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);
                        inOffset.value += dwaHeader.dcCompressedSize;
                    }
                    if (dwaHeader.rleRawSize > 0) {
                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);
                        var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
                        var rleBuffer = decodeRunLength(data.buffer);
                        inOffset.value += dwaHeader.rleCompressedSize;
                    }
                    var outBufferEnd = 0;
                    var rowOffsets = new Array(channelData.length);
                    for(var i = 0; i < rowOffsets.length; ++i){
                        rowOffsets[i] = new Array();
                    }
                    for(var y = 0; y < info.lines; ++y){
                        for(var chan = 0; chan < channelData.length; ++chan){
                            rowOffsets[chan].push(outBufferEnd);
                            outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;
                        }
                    }
                    lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);
                    for(var i = 0; i < channelData.length; ++i){
                        var cd = channelData[i];
                        if (cd.decoded) continue;
                        switch(cd.compression){
                            case RLE:
                                var row = 0;
                                var rleOffset = 0;
                                for(var y = 0; y < info.lines; ++y){
                                    var rowOffsetBytes = rowOffsets[i][row];
                                    for(var x = 0; x < cd.width; ++x){
                                        for(var _byte = 0; _byte < INT16_SIZE * cd.type; ++_byte){
                                            outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + _byte * cd.width * cd.height];
                                        }
                                        rleOffset++;
                                    }
                                    row++;
                                }
                                break;
                            case LOSSY_DCT:
                            default:
                                throw "EXRLoader.parse: unsupported channel compression";
                        }
                    }
                    return new DataView(outBuffer.buffer);
                }
                function parseNullTerminatedString(buffer2, offset2) {
                    var uintBuffer = new Uint8Array(buffer2);
                    var endOffset = 0;
                    while(uintBuffer[offset2.value + endOffset] != 0){
                        endOffset += 1;
                    }
                    var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));
                    offset2.value = offset2.value + endOffset + 1;
                    return stringValue;
                }
                function parseFixedLengthString(buffer2, offset2, size) {
                    var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));
                    offset2.value = offset2.value + size;
                    return stringValue;
                }
                function parseRational(dataView, offset2) {
                    var x = parseInt32(dataView, offset2);
                    var y = parseUint32(dataView, offset2);
                    return [
                        x,
                        y
                    ];
                }
                function parseTimecode(dataView, offset2) {
                    var x = parseUint32(dataView, offset2);
                    var y = parseUint32(dataView, offset2);
                    return [
                        x,
                        y
                    ];
                }
                function parseInt32(dataView, offset2) {
                    var Int32 = dataView.getInt32(offset2.value, true);
                    offset2.value = offset2.value + INT32_SIZE;
                    return Int32;
                }
                function parseUint32(dataView, offset2) {
                    var Uint32 = dataView.getUint32(offset2.value, true);
                    offset2.value = offset2.value + INT32_SIZE;
                    return Uint32;
                }
                function parseUint8Array(uInt8Array2, offset2) {
                    var Uint8 = uInt8Array2[offset2.value];
                    offset2.value = offset2.value + INT8_SIZE;
                    return Uint8;
                }
                function parseUint8(dataView, offset2) {
                    var Uint8 = dataView.getUint8(offset2.value);
                    offset2.value = offset2.value + INT8_SIZE;
                    return Uint8;
                }
                var parseInt64 = function parseInt64(dataView, offset2) {
                    var _int;
                    if ("getBigInt64" in DataView.prototype) {
                        _int = Number(dataView.getBigInt64(offset2.value, true));
                    } else {
                        _int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);
                    }
                    offset2.value += ULONG_SIZE;
                    return _int;
                };
                function parseFloat32(dataView, offset2) {
                    var _float = dataView.getFloat32(offset2.value, true);
                    offset2.value += FLOAT32_SIZE;
                    return _float;
                }
                function decodeFloat32(dataView, offset2) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(parseFloat32(dataView, offset2));
                }
                function decodeFloat16(binary) {
                    var exponent = (binary & 31744) >> 10, fraction = binary & 1023;
                    return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));
                }
                function parseUint16(dataView, offset2) {
                    var Uint16 = dataView.getUint16(offset2.value, true);
                    offset2.value += INT16_SIZE;
                    return Uint16;
                }
                function parseFloat16(buffer2, offset2) {
                    return decodeFloat16(parseUint16(buffer2, offset2));
                }
                function parseChlist(dataView, buffer2, offset2, size) {
                    var startOffset = offset2.value;
                    var channels = [];
                    while(offset2.value < startOffset + size - 1){
                        var name = parseNullTerminatedString(buffer2, offset2);
                        var pixelType = parseInt32(dataView, offset2);
                        var pLinear = parseUint8(dataView, offset2);
                        offset2.value += 3;
                        var xSampling = parseInt32(dataView, offset2);
                        var ySampling = parseInt32(dataView, offset2);
                        channels.push({
                            name: name,
                            pixelType: pixelType,
                            pLinear: pLinear,
                            xSampling: xSampling,
                            ySampling: ySampling
                        });
                    }
                    offset2.value += 1;
                    return channels;
                }
                function parseChromaticities(dataView, offset2) {
                    var redX = parseFloat32(dataView, offset2);
                    var redY = parseFloat32(dataView, offset2);
                    var greenX = parseFloat32(dataView, offset2);
                    var greenY = parseFloat32(dataView, offset2);
                    var blueX = parseFloat32(dataView, offset2);
                    var blueY = parseFloat32(dataView, offset2);
                    var whiteX = parseFloat32(dataView, offset2);
                    var whiteY = parseFloat32(dataView, offset2);
                    return {
                        redX: redX,
                        redY: redY,
                        greenX: greenX,
                        greenY: greenY,
                        blueX: blueX,
                        blueY: blueY,
                        whiteX: whiteX,
                        whiteY: whiteY
                    };
                }
                function parseCompression(dataView, offset2) {
                    var compressionCodes = [
                        "NO_COMPRESSION",
                        "RLE_COMPRESSION",
                        "ZIPS_COMPRESSION",
                        "ZIP_COMPRESSION",
                        "PIZ_COMPRESSION",
                        "PXR24_COMPRESSION",
                        "B44_COMPRESSION",
                        "B44A_COMPRESSION",
                        "DWAA_COMPRESSION",
                        "DWAB_COMPRESSION"
                    ];
                    var compression = parseUint8(dataView, offset2);
                    return compressionCodes[compression];
                }
                function parseBox2i(dataView, offset2) {
                    var xMin = parseUint32(dataView, offset2);
                    var yMin = parseUint32(dataView, offset2);
                    var xMax = parseUint32(dataView, offset2);
                    var yMax = parseUint32(dataView, offset2);
                    return {
                        xMin: xMin,
                        yMin: yMin,
                        xMax: xMax,
                        yMax: yMax
                    };
                }
                function parseLineOrder(dataView, offset2) {
                    var lineOrders = [
                        "INCREASING_Y"
                    ];
                    var lineOrder = parseUint8(dataView, offset2);
                    return lineOrders[lineOrder];
                }
                function parseV2f(dataView, offset2) {
                    var x = parseFloat32(dataView, offset2);
                    var y = parseFloat32(dataView, offset2);
                    return [
                        x,
                        y
                    ];
                }
                function parseV3f(dataView, offset2) {
                    var x = parseFloat32(dataView, offset2);
                    var y = parseFloat32(dataView, offset2);
                    var z = parseFloat32(dataView, offset2);
                    return [
                        x,
                        y,
                        z
                    ];
                }
                function parseValue(dataView, buffer2, offset2, type, size) {
                    if (type === "string" || type === "stringvector" || type === "iccProfile") {
                        return parseFixedLengthString(buffer2, offset2, size);
                    } else if (type === "chlist") {
                        return parseChlist(dataView, buffer2, offset2, size);
                    } else if (type === "chromaticities") {
                        return parseChromaticities(dataView, offset2);
                    } else if (type === "compression") {
                        return parseCompression(dataView, offset2);
                    } else if (type === "box2i") {
                        return parseBox2i(dataView, offset2);
                    } else if (type === "lineOrder") {
                        return parseLineOrder(dataView, offset2);
                    } else if (type === "float") {
                        return parseFloat32(dataView, offset2);
                    } else if (type === "v2f") {
                        return parseV2f(dataView, offset2);
                    } else if (type === "v3f") {
                        return parseV3f(dataView, offset2);
                    } else if (type === "int") {
                        return parseInt32(dataView, offset2);
                    } else if (type === "rational") {
                        return parseRational(dataView, offset2);
                    } else if (type === "timecode") {
                        return parseTimecode(dataView, offset2);
                    } else if (type === "preview") {
                        offset2.value += size;
                        return "skipped";
                    } else {
                        offset2.value += size;
                        return void 0;
                    }
                }
                function parseHeader(dataView, buffer2, offset2) {
                    var EXRHeader2 = {};
                    if (dataView.getUint32(0, true) != 20000630) {
                        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
                    }
                    EXRHeader2.version = dataView.getUint8(4);
                    var spec = dataView.getUint8(5);
                    EXRHeader2.spec = {
                        singleTile: !!(spec & 2),
                        longName: !!(spec & 4),
                        deepFormat: !!(spec & 8),
                        multiPart: !!(spec & 16)
                    };
                    offset2.value = 8;
                    var keepReading = true;
                    while(keepReading){
                        var attributeName = parseNullTerminatedString(buffer2, offset2);
                        if (attributeName == 0) {
                            keepReading = false;
                        } else {
                            var attributeType = parseNullTerminatedString(buffer2, offset2);
                            var attributeSize = parseUint32(dataView, offset2);
                            var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);
                            if (attributeValue === void 0) {
                                console.warn("EXRLoader.parse: skipped unknown header attribute type '".concat(attributeType, "'."));
                            } else {
                                EXRHeader2[attributeName] = attributeValue;
                            }
                        }
                    }
                    if ((spec & ~4) != 0) {
                        console.error("EXRHeader:", EXRHeader2);
                        throw "THREE.EXRLoader: provided file is currently unsupported.";
                    }
                    return EXRHeader2;
                }
                function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {
                    var EXRDecoder2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({
                        size: 0,
                        viewer: dataView,
                        array: uInt8Array2,
                        offset: offset2,
                        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,
                        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,
                        channels: EXRHeader2.channels.length,
                        bytesPerLine: null,
                        lines: null,
                        inputSize: null,
                        type: EXRHeader2.channels[0].pixelType,
                        uncompress: null,
                        getter: null,
                        format: null
                    }, hasColorSpace ? "colorSpace" : "encoding", null);
                    switch(EXRHeader2.compression){
                        case "NO_COMPRESSION":
                            EXRDecoder2.lines = 1;
                            EXRDecoder2.uncompress = uncompressRAW;
                            break;
                        case "RLE_COMPRESSION":
                            EXRDecoder2.lines = 1;
                            EXRDecoder2.uncompress = uncompressRLE;
                            break;
                        case "ZIPS_COMPRESSION":
                            EXRDecoder2.lines = 1;
                            EXRDecoder2.uncompress = uncompressZIP;
                            break;
                        case "ZIP_COMPRESSION":
                            EXRDecoder2.lines = 16;
                            EXRDecoder2.uncompress = uncompressZIP;
                            break;
                        case "PIZ_COMPRESSION":
                            EXRDecoder2.lines = 32;
                            EXRDecoder2.uncompress = uncompressPIZ;
                            break;
                        case "PXR24_COMPRESSION":
                            EXRDecoder2.lines = 16;
                            EXRDecoder2.uncompress = uncompressPXR;
                            break;
                        case "DWAA_COMPRESSION":
                            EXRDecoder2.lines = 32;
                            EXRDecoder2.uncompress = uncompressDWA;
                            break;
                        case "DWAB_COMPRESSION":
                            EXRDecoder2.lines = 256;
                            EXRDecoder2.uncompress = uncompressDWA;
                            break;
                        default:
                            throw "EXRLoader.parse: " + EXRHeader2.compression + " is unsupported";
                    }
                    EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;
                    if (EXRDecoder2.type == 1) {
                        switch(outputType){
                            case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                                EXRDecoder2.getter = parseFloat16;
                                EXRDecoder2.inputSize = INT16_SIZE;
                                break;
                            case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                                EXRDecoder2.getter = parseUint16;
                                EXRDecoder2.inputSize = INT16_SIZE;
                                break;
                        }
                    } else if (EXRDecoder2.type == 2) {
                        switch(outputType){
                            case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                                EXRDecoder2.getter = parseFloat32;
                                EXRDecoder2.inputSize = FLOAT32_SIZE;
                                break;
                            case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                                EXRDecoder2.getter = decodeFloat32;
                                EXRDecoder2.inputSize = FLOAT32_SIZE;
                        }
                    } else {
                        throw "EXRLoader.parse: unsupported pixelType " + EXRDecoder2.type + " for " + EXRHeader2.compression + ".";
                    }
                    EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;
                    for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);
                    EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;
                    var size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;
                    switch(outputType){
                        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
                            EXRDecoder2.byteArray = new Float32Array(size);
                            if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);
                            break;
                        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                            EXRDecoder2.byteArray = new Uint16Array(size);
                            if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);
                            break;
                        default:
                            console.error("THREE.EXRLoader: unsupported type: ", outputType);
                            break;
                    }
                    EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;
                    if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"];
                    else EXRDecoder2.format = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RedFormat"];
                    if (hasColorSpace) EXRDecoder2.colorSpace = "srgb-linear";
                    else EXRDecoder2.encoding = 3e3;
                    return EXRDecoder2;
                }
                var bufferDataView = new DataView(buffer);
                var uInt8Array = new Uint8Array(buffer);
                var offset = {
                    value: 0
                };
                var EXRHeader = parseHeader(bufferDataView, buffer, offset);
                var EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);
                var tmpOffset = {
                    value: 0
                };
                var channelOffsets = {
                    R: 0,
                    G: 1,
                    B: 2,
                    A: 3,
                    Y: 0
                };
                for(var scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){
                    var line = parseUint32(bufferDataView, offset);
                    EXRDecoder.size = parseUint32(bufferDataView, offset);
                    EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;
                    var isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;
                    var viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);
                    offset.value += EXRDecoder.size;
                    for(var line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){
                        var true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
                        if (true_y >= EXRDecoder.height) break;
                        for(var channelID = 0; channelID < EXRDecoder.channels; channelID++){
                            var cOff = channelOffsets[EXRHeader.channels[channelID].name];
                            for(var x = 0; x < EXRDecoder.width; x++){
                                tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;
                                var outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;
                                EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);
                            }
                        }
                    }
                }
                var _obj;
                return _obj = {
                    header: EXRHeader,
                    width: EXRDecoder.width,
                    height: EXRDecoder.height,
                    data: EXRDecoder.byteArray,
                    format: EXRDecoder.format
                }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, hasColorSpace ? "colorSpace" : "encoding", EXRDecoder[hasColorSpace ? "colorSpace" : "encoding"]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, "type", this.type), _obj;
            }
        },
        {
            key: "setDataType",
            value: function setDataType(value) {
                this.type = value;
                return this;
            }
        },
        {
            key: "load",
            value: function load(url, onLoad, onProgress, onError) {
                function onLoadCallback(texture, texData) {
                    if (hasColorSpace) texture.colorSpace = texData.colorSpace;
                    else texture.encoding = texData.encoding;
                    texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                    texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"];
                    texture.generateMipmaps = false;
                    texture.flipY = false;
                    if (onLoad) onLoad(texture, texData);
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_get_prototype_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(EXRLoader.prototype), "load", this).call(this, url, onLoadCallback, onProgress, onError);
            }
        }
    ]);
    return EXRLoader;
}(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTextureLoader"]);
;
 //# sourceMappingURL=EXRLoader.js.map
}),
"[project]/andreas-technology-v2/node_modules/three-stdlib/node_modules/fflate/esm/browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
__turbopack_context__.s([
    "AsyncCompress",
    ()=>AsyncGzip,
    "AsyncDecompress",
    ()=>AsyncDecompress,
    "AsyncDeflate",
    ()=>AsyncDeflate,
    "AsyncGunzip",
    ()=>AsyncGunzip,
    "AsyncGzip",
    ()=>AsyncGzip,
    "AsyncInflate",
    ()=>AsyncInflate,
    "AsyncUnzipInflate",
    ()=>AsyncUnzipInflate,
    "AsyncUnzlib",
    ()=>AsyncUnzlib,
    "AsyncZipDeflate",
    ()=>AsyncZipDeflate,
    "AsyncZlib",
    ()=>AsyncZlib,
    "Compress",
    ()=>Gzip,
    "DecodeUTF8",
    ()=>DecodeUTF8,
    "Decompress",
    ()=>Decompress,
    "Deflate",
    ()=>Deflate,
    "EncodeUTF8",
    ()=>EncodeUTF8,
    "Gunzip",
    ()=>Gunzip,
    "Gzip",
    ()=>Gzip,
    "Inflate",
    ()=>Inflate,
    "Unzip",
    ()=>Unzip,
    "UnzipInflate",
    ()=>UnzipInflate,
    "UnzipPassThrough",
    ()=>UnzipPassThrough,
    "Unzlib",
    ()=>Unzlib,
    "Zip",
    ()=>Zip,
    "ZipDeflate",
    ()=>ZipDeflate,
    "ZipPassThrough",
    ()=>ZipPassThrough,
    "Zlib",
    ()=>Zlib,
    "compress",
    ()=>gzip,
    "compressSync",
    ()=>gzipSync,
    "decompress",
    ()=>decompress,
    "decompressSync",
    ()=>decompressSync,
    "deflate",
    ()=>deflate,
    "deflateSync",
    ()=>deflateSync,
    "gunzip",
    ()=>gunzip,
    "gunzipSync",
    ()=>gunzipSync,
    "gzip",
    ()=>gzip,
    "gzipSync",
    ()=>gzipSync,
    "inflate",
    ()=>inflate,
    "inflateSync",
    ()=>inflateSync,
    "strFromU8",
    ()=>strFromU8,
    "strToU8",
    ()=>strToU8,
    "unzip",
    ()=>unzip,
    "unzipSync",
    ()=>unzipSync,
    "unzlib",
    ()=>unzlib,
    "unzlibSync",
    ()=>unzlibSync,
    "zip",
    ()=>zip,
    "zipSync",
    ()=>zipSync,
    "zlib",
    ()=>zlib,
    "zlibSync",
    ()=>zlibSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
;
var ch2 = {};
var wk = function wk(c, id, msg, transfer, cb) {
    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
        c
    ], {
        type: 'text/javascript'
    }))));
    w.onerror = function(e) {
        return cb(e.error, null);
    };
    w.onmessage = function(e) {
        return cb(null, e.data);
    };
    w.postMessage(msg, transfer);
    return w;
};
// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
// fixed length extra bits
var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */ 0,
    0,
    /* impossible */ 0
]);
// fixed distance extra bits
// see fleb note
var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */ 0,
    0
]);
// code length index map
var clim = new u8([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]);
// get base, reverse index map from extra bits
var freb = function freb(eb, start) {
    var b = new u16(31);
    for(var i = 0; i < 31; ++i){
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new u32(b[30]);
    for(var i = 1; i < 30; ++i){
        for(var j = b[i]; j < b[i + 1]; ++j){
            r[j] = j - b[i] << 5 | i;
        }
    }
    return [
        b,
        r
    ];
};
var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for(var i = 0; i < 32768; ++i){
    // reverse table algorithm from SO
    var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;
    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;
    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;
    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = function hMap(cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for(; i < s; ++i)++l[cd[i] - 1];
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for(i = 0; i < mb; ++i){
        le[i] = le[i - 1] + l[i - 1] << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for(i = 0; i < s; ++i){
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = i << 4 | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for(var m = v | (1 << r_1) - 1; v <= m; ++v){
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >>> rvb] = sv;
                }
            }
        }
    } else {
        co = new u16(s);
        for(i = 0; i < s; ++i){
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
            }
        }
    }
    return co;
};
// fixed length tree
var flt = new u8(288);
for(var i = 0; i < 144; ++i)flt[i] = 8;
for(var i = 144; i < 256; ++i)flt[i] = 9;
for(var i = 256; i < 280; ++i)flt[i] = 7;
for(var i = 280; i < 288; ++i)flt[i] = 8;
// fixed distance tree
var fdt = new u8(32);
for(var i = 0; i < 32; ++i)fdt[i] = 5;
// fixed length map
var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function max(a) {
    var m = a[0];
    for(var i = 1; i < a.length; ++i){
        if (a[i] > m) m = a[i];
    }
    return m;
};
// read d, starting at bit p and mask with m
var bits = function bits(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function bits16(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
// get end of byte
var shft = function shft(p) {
    return (p / 8 | 0) + (p & 7 && 1);
};
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function slc(v, s, e) {
    if (s == null || s < 0) s = 0;
    if (e == null || e > v.length) e = v.length;
    // can't use .constructor in case user-supplied
    var n = new ((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(v, u16) ? u16 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(v, u32) ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
};
// expands raw DEFLATE data
var inflt = function inflt(dat, buf, st) {
    // source length
    var sl = dat.length;
    if (!sl || st && !st.l && sl < 5) return buf || new u8(0);
    // have to estimate size
    var noBuf = !buf || st;
    // no state
    var noSt = !st || st.i;
    if (!st) st = {};
    // Assumes roughly 33% compression ratio average
    if (!buf) buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function cbuf(l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var _final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            st.f = _final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
                if (t > sl) {
                    if (noSt) throw 'unexpected EOF';
                    break;
                }
                // ensure size
                if (noBuf) cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8;
                continue;
            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for(var i = 0; i < hcLen; ++i){
                    // use index map to get real code
                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
                }
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for(var i = 0; i < tl;){
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >>> 4;
                    // code length to copy
                    if (s < 16) {
                        ldt[i++] = s;
                    } else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;
                        while(n--)ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            } else throw 'invalid block type';
            if (pos > tbts) {
                if (noSt) throw 'unexpected EOF';
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17;
        if (noBuf) cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for(;; lpos = pos){
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt) throw 'unexpected EOF';
                break;
            }
            if (!c) throw 'invalid length/literal';
            if (sym < 256) buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            } else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                if (!d) throw 'invalid distance';
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                }
                if (pos > tbts) {
                    if (noSt) throw 'unexpected EOF';
                    break;
                }
                if (noBuf) cbuf(bt + 131072);
                var end = bt + add;
                for(; bt < end; bt += 4){
                    buf[bt] = buf[bt - dt];
                    buf[bt + 1] = buf[bt + 1 - dt];
                    buf[bt + 2] = buf[bt + 2 - dt];
                    buf[bt + 3] = buf[bt + 3 - dt];
                }
                bt = end;
            }
        }
        st.l = lm, st.p = lpos, st.b = bt;
        if (lm) _final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    }while (!_final)
    return bt == buf.length ? buf : slc(buf, 0, bt);
};
// starting at p, write the minimum number of bits that can hold v to d
var wbits = function wbits(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >>> 8;
};
// starting at p, write the minimum number of bits (>8) that can hold v to d
var wbits16 = function wbits16(d, p, v) {
    v <<= p & 7;
    var o = p / 8 | 0;
    d[o] |= v;
    d[o + 1] |= v >>> 8;
    d[o + 2] |= v >>> 16;
};
// creates code lengths from a frequency table
var hTree = function hTree(d, mb) {
    // Need extra info to make a tree
    var t = [];
    for(var i = 0; i < d.length; ++i){
        if (d[i]) t.push({
            s: i,
            f: d[i]
        });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s) return [
        et,
        0
    ];
    if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return [
            v,
            1
        ];
    }
    t.sort(function(a, b) {
        return a.f - b.f;
    });
    // after i2 reaches last ind, will be stopped
    // freq must be greater than largest possible number of symbols
    t.push({
        s: -1,
        f: 25001
    });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = {
        s: -1,
        f: l.f + r.f,
        l: l,
        r: r
    };
    // efficient algorithm from UZIP.js
    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
    // symbols that combined have high freq, will start processing i2 (high-freq,
    // non-composite) symbols instead
    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
    while(i1 != s - 1){
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = {
            s: -1,
            f: l.f + r.f,
            l: l,
            r: r
        };
    }
    var maxSym = t2[0].s;
    for(var i = 1; i < s; ++i){
        if (t2[i].s > maxSym) maxSym = t2[i].s;
    }
    // code lengths
    var tr = new u16(maxSym + 1);
    // max bits in tree
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
        // more algorithms from UZIP.js
        // TODO: find out how this code works (debt)
        //  ind    debt
        var i = 0, dt = 0;
        //    left            cost
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function(a, b) {
            return tr[b.s] - tr[a.s] || a.f - b.f;
        });
        for(; i < s; ++i){
            var i2_1 = t2[i].s;
            if (tr[i2_1] > mb) {
                dt += cst - (1 << mbt - tr[i2_1]);
                tr[i2_1] = mb;
            } else break;
        }
        dt >>>= lft;
        while(dt > 0){
            var i2_2 = t2[i].s;
            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;
            else ++i;
        }
        for(; i >= 0 && dt; --i){
            var i2_3 = t2[i].s;
            if (tr[i2_3] == mb) {
                --tr[i2_3];
                ++dt;
            }
        }
        mbt = mb;
    }
    return [
        new u8(tr),
        mbt
    ];
};
// get the max length and assign length codes
var ln = function ln1(n, l, d) {
    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
// length codes generation
var lc = function lc(c) {
    var s = c.length;
    // Note that the semicolon was intentional
    while(s && !c[--s]);
    var cl = new u16(++s);
    //  ind      num         streak
    var cli = 0, cln = c[0], cls = 1;
    var w = function w(v) {
        cl[cli++] = v;
    };
    for(var i = 1; i <= s; ++i){
        if (c[i] == cln && i != s) ++cls;
        else {
            if (!cln && cls > 2) {
                for(; cls > 138; cls -= 138)w(32754);
                if (cls > 2) {
                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
                    cls = 0;
                }
            } else if (cls > 3) {
                w(cln), --cls;
                for(; cls > 6; cls -= 6)w(8304);
                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
            }
            while(cls--)w(cln);
            cls = 1;
            cln = c[i];
        }
    }
    return [
        cl.subarray(0, cli),
        s
    ];
};
// calculate the length of output from tree, code lengths
var clen = function clen(cf, cl) {
    var l = 0;
    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];
    return l;
};
// writes a fixed block
// returns the new bit pos
var wfblk = function wfblk(out, pos, dat) {
    // no need to write 00 as type: TypedArray defaults to 0
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >>> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
};
// writes a block
var wblk = function wblk(dat, out, _final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, _final);
    ++lf[256];
    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];
    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];
    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
    var lcfreq = new u16(19);
    for(var i = 0; i < lclt.length; ++i)lcfreq[lclt[i] & 31]++;
    for(var i = 0; i < lcdt.length; ++i)lcfreq[lcdt[i] & 31]++;
    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
    var nlcc = 19;
    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);
    var flen = bl + 5 << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
    if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);
        p += 3 * nlcc;
        var lcts = [
            lclt,
            lcdt
        ];
        for(var it = 0; it < 2; ++it){
            var clct = lcts[it];
            for(var i = 0; i < clct.length; ++i){
                var len = clct[i] & 31;
                wbits(out, p, llm[len]), p += lct[len];
                if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;
            }
        }
    } else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for(var i = 0; i < li; ++i){
        if (syms[i] > 255) {
            var len = syms[i] >>> 18 & 31;
            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
            if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];
            var dst = syms[i] & 31;
            wbits16(out, p, dm[dst]), p += dl[dst];
            if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];
        } else {
            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
        }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
};
// deflate options (nice << 13) | chain
var deo = /*#__PURE__*/ new u32([
    65540,
    131080,
    131088,
    131104,
    262176,
    1048704,
    1048832,
    2114560,
    2117632
]);
// empty
var et = /*#__PURE__*/ new u8(0);
// compresses data into a raw DEFLATE buffer
var dflt = function dflt(dat, lvl, plvl, pre, post, lst) {
    var s = dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
    // writing to this writes to the output buffer
    var w = o.subarray(pre, o.length - post);
    var pos = 0;
    if (!lvl || s < 8) {
        for(var i = 0; i <= s; i += 65535){
            // end
            var e = i + 65535;
            if (e < s) {
                // write full block
                pos = wfblk(w, pos, dat.subarray(i, e));
            } else {
                // write final block
                w[i] = lst;
                pos = wfblk(w, pos, dat.subarray(i, s));
            }
        }
    } else {
        var opt = deo[lvl - 1];
        var n = opt >>> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        //    prev 2-byte val map    curr 2-byte val map
        var prev = new u16(32768), head = new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function hsh(i) {
            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
        };
        // 24576 is an arbitrary number of maximum symbols per block
        // 424 buffer for last block
        var syms = new u32(25000);
        // length/literal freq   distance freq
        var lf = new u16(288), df = new u16(32);
        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
        for(; i < s; ++i){
            // hash value
            // deopt when i > s - 3 - at end, deopt acceptable
            var hv = hsh(i);
            // index mod 32768    previous index mod
            var imod = i & 32767, pimod = head[hv];
            prev[imod] = pimod;
            head[hv] = imod;
            // We always should modify head and prev, but only add symbols if
            // this data is not yet processed ("wait" for wait index)
            if (wi <= i) {
                // bytes remaining
                var rem = s - i;
                if ((lc_1 > 7000 || li > 24576) && rem > 423) {
                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                    li = lc_1 = eb = 0, bs = i;
                    for(var j = 0; j < 286; ++j)lf[j] = 0;
                    for(var j = 0; j < 30; ++j)df[j] = 0;
                }
                //  len    dist   chain
                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                if (rem > 2 && hv == hsh(i - dif)) {
                    var maxn = Math.min(n, rem) - 1;
                    var maxd = Math.min(32767, i);
                    // max possible length
                    // not capped at dif because decompressors implement "rolling" index population
                    var ml = Math.min(258, rem);
                    while(dif <= maxd && --ch_1 && imod != pimod){
                        if (dat[i + l] == dat[i + l - dif]) {
                            var nl = 0;
                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);
                            if (nl > l) {
                                l = nl, d = dif;
                                // break out early when we reach "nice" (we are satisfied enough)
                                if (nl > maxn) break;
                                // now, find the rarest 2-byte sequence within this
                                // length of literals and search for that instead.
                                // Much faster than just using the start
                                var mmd = Math.min(dif, nl - 2);
                                var md = 0;
                                for(var j = 0; j < mmd; ++j){
                                    var ti = i - dif + j + 32768 & 32767;
                                    var pti = prev[ti];
                                    var cd = ti - pti + 32768 & 32767;
                                    if (cd > md) md = cd, pimod = ti;
                                }
                            }
                        }
                        // check the previous match
                        imod = pimod, pimod = prev[imod];
                        dif += imod - pimod + 32768 & 32767;
                    }
                }
                // d will be nonzero only when a match was found
                if (d) {
                    // store both dist and len data in one Uint32
                    // Make sure this is recognized as a len/dist with 28th bit (2^28)
                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
                    var lin = revfl[l] & 31, din = revfd[d] & 31;
                    eb += fleb[lin] + fdeb[din];
                    ++lf[257 + lin];
                    ++df[din];
                    wi = i + l;
                    ++lc_1;
                } else {
                    syms[li++] = dat[i];
                    ++lf[dat[i]];
                }
            }
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        // this is the easiest way to avoid needing to maintain state
        if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);
    }
    return slc(o, 0, pre + shft(pos) + post);
};
// CRC32 table
var crct = /*#__PURE__*/ function() {
    var t = new Int32Array(256);
    for(var i = 0; i < 256; ++i){
        var c = i, k = 9;
        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;
        t[i] = c;
    }
    return t;
}();
// CRC32
var crc = function crc() {
    var c = -1;
    return {
        p: function p(d) {
            // closures have awful performance
            var cr = c;
            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
            c = cr;
        },
        d: function d() {
            return ~c;
        }
    };
};
// Alder32
var adler = function adler() {
    var a = 1, b = 0;
    return {
        p: function p(d) {
            // closures have awful performance
            var n = a, m = b;
            var l = d.length;
            for(var i = 0; i != l;){
                var e = Math.min(i + 2655, l);
                for(; i < e; ++i)m += n += d[i];
                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
            }
            a = n, b = m;
        },
        d: function d() {
            a %= 65521, b %= 65521;
            return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;
        }
    };
};
;
// deflate with opts
var dopt = function dopt(dat, opt, pre, post, st) {
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
};
// Walmart object spread
var mrg = function mrg(a, b) {
    var o = {};
    for(var k in a)o[k] = a[k];
    for(var k in b)o[k] = b[k];
    return o;
};
// worker clone
// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
// This took me three weeks to figure out how to do.
var wcln = function wcln(fn, fnStr, td) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');
    for(var i = 0; i < dt.length; ++i){
        var v = dt[i], k = ks[i];
        if (typeof v == 'function') {
            fnStr += ';' + k + '=';
            var st_1 = v.toString();
            if (v.prototype) {
                // for global objects
                if (st_1.indexOf('[native code]') != -1) {
                    var spInd = st_1.indexOf(' ', 8) + 1;
                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
                } else {
                    fnStr += st_1;
                    for(var t in v.prototype)fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
                }
            } else fnStr += st_1;
        } else td[k] = v;
    }
    return [
        fnStr,
        td
    ];
};
var ch = [];
// clone bufs
var cbfs = function cbfs(v) {
    var tl = [];
    for(var k in v){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(v[k], u8) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(v[k], u16) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(v[k], u32)) tl.push((v[k] = new v[k].constructor(v[k])).buffer);
    }
    return tl;
};
// use a worker to execute code
var wrkr = function wrkr(fns, init, id, cb) {
    var _a;
    if (!ch[id]) {
        var fnStr = '', td_1 = {}, m = fns.length - 1;
        for(var i = 0; i < m; ++i)_a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];
        ch[id] = wcln(fns[m], fnStr, td_1);
    }
    var td = mrg({}, ch[id][1]);
    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
};
// base async inflate fn
var bInflt = function bInflt() {
    return [
        u8,
        u16,
        u32,
        fleb,
        fdeb,
        clim,
        fl,
        fd,
        flrm,
        fdrm,
        rev,
        hMap,
        max,
        bits,
        bits16,
        shft,
        slc,
        inflt,
        inflateSync,
        pbf,
        gu8
    ];
};
var bDflt = function bDflt() {
    return [
        u8,
        u16,
        u32,
        fleb,
        fdeb,
        clim,
        revfl,
        revfd,
        flm,
        flt,
        fdm,
        fdt,
        rev,
        deo,
        et,
        hMap,
        wbits,
        wbits16,
        hTree,
        ln,
        lc,
        clen,
        wfblk,
        wblk,
        shft,
        slc,
        dflt,
        dopt,
        deflateSync,
        pbf
    ];
};
// gzip extra
var gze = function gze() {
    return [
        gzh,
        gzhl,
        wbytes,
        crc,
        crct
    ];
};
// gunzip extra
var guze = function guze() {
    return [
        gzs,
        gzl
    ];
};
// zlib extra
var zle = function zle() {
    return [
        zlh,
        wbytes,
        adler
    ];
};
// unzlib extra
var zule = function zule() {
    return [
        zlv
    ];
};
// post buf
var pbf = function pbf(msg) {
    return postMessage(msg, [
        msg.buffer
    ]);
};
// get u8
var gu8 = function gu8(o) {
    return o && o.size && new u8(o.size);
};
// async helper
var cbify = function cbify(dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function(err, dat) {
        w.terminate();
        cb(err, dat);
    });
    w.postMessage([
        dat,
        opts
    ], opts.consume ? [
        dat.buffer
    ] : []);
    return function() {
        w.terminate();
    };
};
// auto stream
var astrm = function astrm(strm) {
    strm.ondata = function(dat, _final) {
        return postMessage([
            dat,
            _final
        ], [
            dat.buffer
        ]);
    };
    return function(ev) {
        return strm.push(ev.data[0], ev.data[1]);
    };
};
// async stream attach
var astrmify = function astrmify(fns, strm, opts, init, id) {
    var t;
    var w = wrkr(fns, init, id, function(err, dat) {
        if (err) w.terminate(), strm.ondata.call(strm, err);
        else {
            if (dat[1]) w.terminate();
            strm.ondata.call(strm, err, dat[0], dat[1]);
        }
    });
    w.postMessage(opts);
    strm.push = function(d, f) {
        if (t) throw 'stream finished';
        if (!strm.ondata) throw 'no stream handler';
        w.postMessage([
            d,
            t = f
        ], [
            d.buffer
        ]);
    };
    strm.terminate = function() {
        w.terminate();
    };
};
// read 2 bytes
var b2 = function b2(d, b) {
    return d[b] | d[b + 1] << 8;
};
// read 4 bytes
var b4 = function b4(d, b) {
    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function b8(d, b) {
    return b4(d, b) + b4(d, b + 4) * 4294967296;
};
// write bytes
var wbytes = function wbytes(d, b, v) {
    for(; v; ++b)d[b] = v, v >>>= 8;
};
// gzip header
var gzh = function gzh(c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix
    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));
    if (fn) {
        c[3] = 8;
        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);
    }
};
// gzip footer: -8 to -4 = CRC, -4 to -0 is length
// gzip start
var gzs = function gzs(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw 'invalid gzip data';
    var flg = d[3];
    var st = 10;
    if (flg & 4) st += d[10] | (d[11] << 8) + 2;
    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);
    return st + (flg & 2);
};
// gzip length
var gzl = function gzl(d) {
    var l = d.length;
    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
// gzip header length
var gzhl = function gzhl(o) {
    return 10 + (o.filename && o.filename.length + 1 || 0);
};
// zlib header
var zlh = function zlh(c, o) {
    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);
};
// zlib valid
var zlv = function zlv(d) {
    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';
    if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
};
function AsyncCmpStrm(opts, cb) {
    if (!cb && typeof opts == 'function') cb = opts, opts = {};
    this.ondata = cb;
    return opts;
}
// zlib footer: -4 to -0 is Adler32
/**
 * Streaming DEFLATE compression
 */ var Deflate = function() {
    function Deflate(opts, cb) {
        if (!cb && typeof opts == 'function') cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
    }
    Deflate.prototype.p = function(c, f) {
        this.ondata(dopt(c, this.o, 0, 0, !f), f);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Deflate.prototype.push = function(chunk, _final) {
        if (this.d) throw 'stream finished';
        if (!this.ondata) throw 'no stream handler';
        this.d = _final;
        this.p(chunk, _final || false);
    };
    return Deflate;
}();
;
/**
 * Asynchronous streaming DEFLATE compression
 */ var AsyncDeflate = function() {
    function AsyncDeflate(opts, cb) {
        astrmify([
            bDflt,
            function() {
                return [
                    astrm,
                    Deflate
                ];
            }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
            var strm = new Deflate(ev.data);
            onmessage = astrm(strm);
        }, 6);
    }
    return AsyncDeflate;
}();
;
function deflate(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [
        bDflt
    ], function(ev) {
        return pbf(deflateSync(ev.data[0], ev.data[1]));
    }, 0, cb);
}
function deflateSync(data, opts) {
    return dopt(data, opts || {}, 0, 0);
}
/**
 * Streaming DEFLATE decompression
 */ var Inflate = function() {
    /**
     * Creates an inflation stream
     * @param cb The callback to call whenever data is inflated
     */ function Inflate(cb) {
        this.s = {};
        this.p = new u8(0);
        this.ondata = cb;
    }
    Inflate.prototype.e = function(c) {
        if (this.d) throw 'stream finished';
        if (!this.ondata) throw 'no stream handler';
        var l = this.p.length;
        var n = new u8(l + c.length);
        n.set(this.p), n.set(c, l), this.p = n;
    };
    Inflate.prototype.c = function(_final) {
        this.d = this.s.i = _final || false;
        var bts = this.s.b;
        var dt = inflt(this.p, this.o, this.s);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    };
    /**
     * Pushes a chunk to be inflated
     * @param chunk The chunk to push
     * @param final Whether this is the final chunk
     */ Inflate.prototype.push = function(chunk, _final) {
        this.e(chunk), this.c(_final);
    };
    return Inflate;
}();
;
/**
 * Asynchronous streaming DEFLATE decompression
 */ var AsyncInflate = function() {
    /**
     * Creates an asynchronous inflation stream
     * @param cb The callback to call whenever data is deflated
     */ function AsyncInflate(cb) {
        this.ondata = cb;
        astrmify([
            bInflt,
            function() {
                return [
                    astrm,
                    Inflate
                ];
            }
        ], this, 0, function() {
            var strm = new Inflate();
            onmessage = astrm(strm);
        }, 7);
    }
    return AsyncInflate;
}();
;
function inflate(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [
        bInflt
    ], function(ev) {
        return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));
    }, 1, cb);
}
function inflateSync(data, out) {
    return inflt(data, out);
}
// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
/**
 * Streaming GZIP compression
 */ var Gzip = function() {
    function Gzip(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Gzip.prototype.push = function(chunk, _final) {
        Deflate.prototype.push.call(this, chunk, _final);
    };
    Gzip.prototype.p = function(c, f) {
        this.c.p(c);
        this.l += c.length;
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
        if (this.v) gzh(raw, this.o), this.v = 0;
        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f);
    };
    return Gzip;
}();
;
/**
 * Asynchronous streaming GZIP compression
 */ var AsyncGzip = function() {
    function AsyncGzip(opts, cb) {
        astrmify([
            bDflt,
            gze,
            function() {
                return [
                    astrm,
                    Deflate,
                    Gzip
                ];
            }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
            var strm = new Gzip(ev.data);
            onmessage = astrm(strm);
        }, 8);
    }
    return AsyncGzip;
}();
;
function gzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [
        bDflt,
        gze,
        function() {
            return [
                gzipSync
            ];
        }
    ], function(ev) {
        return pbf(gzipSync(ev.data[0], ev.data[1]));
    }, 2, cb);
}
function gzipSync(data, opts) {
    if (!opts) opts = {};
    var c = crc(), l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
/**
 * Streaming GZIP decompression
 */ var Gunzip = function() {
    /**
     * Creates a GUNZIP stream
     * @param cb The callback to call whenever data is inflated
     */ function Gunzip(cb) {
        this.v = 1;
        Inflate.call(this, cb);
    }
    /**
     * Pushes a chunk to be GUNZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Gunzip.prototype.push = function(chunk, _final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
            var s = this.p.length > 3 ? gzs(this.p) : 4;
            if (s >= this.p.length && !_final) return;
            this.p = this.p.subarray(s), this.v = 0;
        }
        if (_final) {
            if (this.p.length < 8) throw 'invalid gzip stream';
            this.p = this.p.subarray(0, -8);
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, _final);
    };
    return Gunzip;
}();
;
/**
 * Asynchronous streaming GZIP decompression
 */ var AsyncGunzip = function() {
    /**
     * Creates an asynchronous GUNZIP stream
     * @param cb The callback to call whenever data is deflated
     */ function AsyncGunzip(cb) {
        this.ondata = cb;
        astrmify([
            bInflt,
            guze,
            function() {
                return [
                    astrm,
                    Inflate,
                    Gunzip
                ];
            }
        ], this, 0, function() {
            var strm = new Gunzip();
            onmessage = astrm(strm);
        }, 9);
    }
    return AsyncGunzip;
}();
;
function gunzip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [
        bInflt,
        guze,
        function() {
            return [
                gunzipSync
            ];
        }
    ], function(ev) {
        return pbf(gunzipSync(ev.data[0]));
    }, 3, cb);
}
function gunzipSync(data, out) {
    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
}
/**
 * Streaming Zlib compression
 */ var Zlib = function() {
    function Zlib(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be zlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Zlib.prototype.push = function(chunk, _final) {
        Deflate.prototype.push.call(this, chunk, _final);
    };
    Zlib.prototype.p = function(c, f) {
        this.c.p(c);
        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
        if (this.v) zlh(raw, this.o), this.v = 0;
        if (f) wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f);
    };
    return Zlib;
}();
;
/**
 * Asynchronous streaming Zlib compression
 */ var AsyncZlib = function() {
    function AsyncZlib(opts, cb) {
        astrmify([
            bDflt,
            zle,
            function() {
                return [
                    astrm,
                    Deflate,
                    Zlib
                ];
            }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
            var strm = new Zlib(ev.data);
            onmessage = astrm(strm);
        }, 10);
    }
    return AsyncZlib;
}();
;
function zlib(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [
        bDflt,
        zle,
        function() {
            return [
                zlibSync
            ];
        }
    ], function(ev) {
        return pbf(zlibSync(ev.data[0], ev.data[1]));
    }, 4, cb);
}
function zlibSync(data, opts) {
    if (!opts) opts = {};
    var a = adler();
    a.p(data);
    var d = dopt(data, opts, 2, 4);
    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
/**
 * Streaming Zlib decompression
 */ var Unzlib = function() {
    /**
     * Creates a Zlib decompression stream
     * @param cb The callback to call whenever data is inflated
     */ function Unzlib(cb) {
        this.v = 1;
        Inflate.call(this, cb);
    }
    /**
     * Pushes a chunk to be unzlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Unzlib.prototype.push = function(chunk, _final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
            if (this.p.length < 2 && !_final) return;
            this.p = this.p.subarray(2), this.v = 0;
        }
        if (_final) {
            if (this.p.length < 4) throw 'invalid zlib stream';
            this.p = this.p.subarray(0, -4);
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, _final);
    };
    return Unzlib;
}();
;
/**
 * Asynchronous streaming Zlib decompression
 */ var AsyncUnzlib = function() {
    /**
     * Creates an asynchronous Zlib decompression stream
     * @param cb The callback to call whenever data is deflated
     */ function AsyncUnzlib(cb) {
        this.ondata = cb;
        astrmify([
            bInflt,
            zule,
            function() {
                return [
                    astrm,
                    Inflate,
                    Unzlib
                ];
            }
        ], this, 0, function() {
            var strm = new Unzlib();
            onmessage = astrm(strm);
        }, 11);
    }
    return AsyncUnzlib;
}();
;
function unzlib(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return cbify(data, opts, [
        bInflt,
        zule,
        function() {
            return [
                unzlibSync
            ];
        }
    ], function(ev) {
        return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));
    }, 5, cb);
}
function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
}
;
;
/**
 * Streaming GZIP, Zlib, or raw DEFLATE decompression
 */ var Decompress = function() {
    /**
     * Creates a decompression stream
     * @param cb The callback to call whenever data is decompressed
     */ function Decompress(cb) {
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Decompress.prototype.push = function(chunk, _final) {
        if (!this.ondata) throw 'no stream handler';
        if (!this.s) {
            if (this.p && this.p.length) {
                var n = new u8(this.p.length + chunk.length);
                n.set(this.p), n.set(chunk, this.p.length);
            } else this.p = chunk;
            if (this.p.length > 2) {
                var _this_1 = this;
                var cb = function cb() {
                    _this_1.ondata.apply(_this_1, arguments);
                };
                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);
                this.s.push(this.p, _final);
                this.p = null;
            }
        } else this.s.push(chunk, _final);
    };
    return Decompress;
}();
;
/**
 * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
 */ var AsyncDecompress = function() {
    /**
   * Creates an asynchronous decompression stream
   * @param cb The callback to call whenever data is decompressed
   */ function AsyncDecompress(cb) {
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ AsyncDecompress.prototype.push = function(chunk, _final) {
        Decompress.prototype.push.call(this, chunk, _final);
    };
    return AsyncDecompress;
}();
;
function decompress(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
}
function decompressSync(data, out) {
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);
}
// flatten a directory structure
var fltn = function fltn1(d, p, t, o) {
    for(var k in d){
        var val = d[k], n = p + k;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(val, u8)) t[n] = [
            val,
            o
        ];
        else if (Array.isArray(val)) t[n] = [
            val[0],
            mrg(o, val[1])
        ];
        else fltn(val, n + '/', t, o);
    }
};
// text encoder
var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, {
        stream: true
    });
    tds = 1;
} catch (e) {}
// decode UTF8
var dutf8 = function dutf8(d) {
    for(var r = '', i = 0;;){
        var c = d[i++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i + eb > d.length) return [
            r,
            slc(d, i - 1)
        ];
        if (!eb) r += String.fromCharCode(c);
        else if (eb == 3) {
            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
    }
};
/**
 * Streaming UTF-8 decoding
 */ var DecodeUTF8 = function() {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is decoded
     */ function DecodeUTF8(cb) {
        this.ondata = cb;
        if (tds) this.t = new TextDecoder();
        else this.p = et;
    }
    /**
     * Pushes a chunk to be decoded from UTF-8 binary
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ DecodeUTF8.prototype.push = function(chunk, _final) {
        if (!this.ondata) throw 'no callback';
        _final = !!_final;
        if (this.t) {
            this.ondata(this.t.decode(chunk, {
                stream: true
            }), _final);
            if (_final) {
                if (this.t.decode().length) throw 'invalid utf-8 data';
                this.t = null;
            }
            return;
        }
        if (!this.p) throw 'stream finished';
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a = dutf8(dat), ch = _a[0], np = _a[1];
        if (_final) {
            if (np.length) throw 'invalid utf-8 data';
            this.p = null;
        } else this.p = np;
        this.ondata(ch, _final);
    };
    return DecodeUTF8;
}();
;
/**
 * Streaming UTF-8 encoding
 */ var EncodeUTF8 = function() {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is encoded
     */ function EncodeUTF8(cb) {
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be encoded to UTF-8
     * @param chunk The string data to push
     * @param final Whether this is the last chunk
     */ EncodeUTF8.prototype.push = function(chunk, _final) {
        if (!this.ondata) throw 'no callback';
        if (this.d) throw 'stream finished';
        this.ondata(strToU8(chunk), this.d = _final || false);
    };
    return EncodeUTF8;
}();
;
function strToU8(str, latin1) {
    if (latin1) {
        var ar_1 = new u8(str.length);
        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);
        return ar_1;
    }
    if (te) return te.encode(str);
    var l = str.length;
    var ar = new u8(str.length + (str.length >> 1));
    var ai = 0;
    var w = function w(v) {
        ar[ai++] = v;
    };
    for(var i = 0; i < l; ++i){
        if (ai + 5 > ar.length) {
            var n = new u8(ai + 8 + (l - i << 1));
            n.set(ar);
            ar = n;
        }
        var c = str.charCodeAt(i);
        if (c < 128 || latin1) w(c);
        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);
        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
    }
    return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
    if (latin1) {
        var r = '';
        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
        return r;
    } else if (td) return td.decode(dat);
    else {
        var _a = dutf8(dat), out = _a[0], ext = _a[1];
        if (ext.length) throw 'invalid utf-8 data';
        return out;
    }
}
;
// deflate bit flag
var dbf = function dbf(l) {
    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
// skip local zip header
var slzh = function slzh(d, b) {
    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
};
// read zip header
var zh = function zh(d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a = z && bs == 4294967295 ? z64e(d, es) : [
        bs,
        b4(d, b + 24),
        b4(d, b + 42)
    ], sc = _a[0], su = _a[1], off = _a[2];
    return [
        b2(d, b + 10),
        sc,
        su,
        fn,
        es + b2(d, b + 30) + b2(d, b + 32),
        off
    ];
};
// read zip64 extra field
var z64e = function z64e(d, b) {
    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));
    return [
        b8(d, b + 12),
        b8(d, b + 4),
        b8(d, b + 20)
    ];
};
// extra field length
var exfl = function exfl(ex) {
    var le = 0;
    if (ex) {
        for(var k in ex){
            var l = ex[k].length;
            if (l > 65535) throw 'extra field too long';
            le += l + 4;
        }
    }
    return le;
};
// write zip header
var wzh = function wzh(d, b, f, fn, u, c, ce, co) {
    var fl = fn.length, ex = f.extra, col = co && co.length;
    var exl = exfl(ex);
    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
    if (ce != null) d[b++] = 20, d[b++] = f.os;
    d[b] = 20, b += 2; // spec compliance? what's that?
    d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;
    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
    if (y < 0 || y > 119) throw 'date not in range 1980-2099';
    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;
    if (c != null) {
        wbytes(d, b, f.crc);
        wbytes(d, b + 4, c);
        wbytes(d, b + 8, f.size);
    }
    wbytes(d, b + 12, fl);
    wbytes(d, b + 14, exl), b += 16;
    if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f.attrs);
        wbytes(d, b + 10, ce), b += 14;
    }
    d.set(fn, b);
    b += fl;
    if (exl) {
        for(var k in ex){
            var exf = ex[k], l = exf.length;
            wbytes(d, b, +k);
            wbytes(d, b + 2, l);
            d.set(exf, b + 4), b += 4 + l;
        }
    }
    if (col) d.set(co, b), b += col;
    return b;
};
// write zip footer (end of central directory)
var wzf = function wzf(o, b, c, d, e) {
    wbytes(o, b, 0x6054B50); // skip disk
    wbytes(o, b + 8, c);
    wbytes(o, b + 10, c);
    wbytes(o, b + 12, d);
    wbytes(o, b + 16, e);
};
/**
 * A pass-through stream to keep data uncompressed in a ZIP archive.
 */ var ZipPassThrough = function() {
    /**
     * Creates a pass-through stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     */ function ZipPassThrough(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
    }
    /**
     * Processes a chunk and pushes to the output stream. You can override this
     * method in a subclass for custom behavior, but by default this passes
     * the data through. You must call this.ondata(err, chunk, final) at some
     * point in this method.
     * @param chunk The chunk to process
     * @param final Whether this is the last chunk
     */ ZipPassThrough.prototype.process = function(chunk, _final) {
        this.ondata(null, chunk, _final);
    };
    /**
     * Pushes a chunk to be added. If you are subclassing this with a custom
     * compression algorithm, note that you must push data from the source
     * file only, pre-compression.
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ ZipPassThrough.prototype.push = function(chunk, _final) {
        if (!this.ondata) throw 'no callback - add to ZIP archive before pushing';
        this.c.p(chunk);
        this.size += chunk.length;
        if (_final) this.crc = this.c.d();
        this.process(chunk, _final || false);
    };
    return ZipPassThrough;
}();
;
// I don't extend because TypeScript extension adds 1kB of runtime bloat
/**
 * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
 * for better performance
 */ var ZipDeflate = function() {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */ function ZipDeflate(filename, opts) {
        var _this_1 = this;
        if (!opts) opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function(dat, _final) {
            _this_1.ondata(null, dat, _final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
    }
    ZipDeflate.prototype.process = function(chunk, _final) {
        try {
            this.d.push(chunk, _final);
        } catch (e) {
            this.ondata(e, null, _final);
        }
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ ZipDeflate.prototype.push = function(chunk, _final) {
        ZipPassThrough.prototype.push.call(this, chunk, _final);
    };
    return ZipDeflate;
}();
;
/**
 * Asynchronous streaming DEFLATE compression for ZIP archives
 */ var AsyncZipDeflate = function() {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */ function AsyncZipDeflate(filename, opts) {
        var _this_1 = this;
        if (!opts) opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function(err, dat, _final) {
            _this_1.ondata(err, dat, _final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
    }
    AsyncZipDeflate.prototype.process = function(chunk, _final) {
        this.d.push(chunk, _final);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ AsyncZipDeflate.prototype.push = function(chunk, _final) {
        ZipPassThrough.prototype.push.call(this, chunk, _final);
    };
    return AsyncZipDeflate;
}();
;
// TODO: Better tree shaking
/**
 * A zippable archive to which files can incrementally be added
 */ var Zip = function() {
    /**
     * Creates an empty ZIP archive to which files can be added
     * @param cb The callback to call whenever data for the generated ZIP archive
     *           is available
     */ function Zip(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
    }
    /**
     * Adds a file to the ZIP archive
     * @param file The file stream to add
     */ Zip.prototype.add = function(file) {
        var _this_1 = this;
        if (this.d & 2) throw 'stream finished';
        var f = strToU8(file.filename), fl = f.length;
        var com = file.comment, o = com && strToU8(com);
        var u = fl != file.filename.length || o && com.length != o.length;
        var hl = fl + exfl(file.extra) + 30;
        if (fl > 65535) throw 'filename too long';
        var header = new u8(hl);
        wzh(header, 0, file, f, u);
        var chks = [
            header
        ];
        var pAll = function pAll() {
            for(var _i = 0, chks_1 = chks; _i < chks_1.length; _i++){
                var chk = chks_1[_i];
                _this_1.ondata(null, chk, false);
            }
            chks = [];
        };
        var tr = this.d;
        this.d = 0;
        var ind = this.u.length;
        var uf = mrg(file, {
            f: f,
            u: u,
            o: o,
            t: function t() {
                if (file.terminate) file.terminate();
            },
            r: function r() {
                pAll();
                if (tr) {
                    var nxt = _this_1.u[ind + 1];
                    if (nxt) nxt.r();
                    else _this_1.d = 1;
                }
                tr = 1;
            }
        });
        var cl = 0;
        file.ondata = function(err, dat, _final) {
            if (err) {
                _this_1.ondata(err, dat, _final);
                _this_1.terminate();
            } else {
                cl += dat.length;
                chks.push(dat);
                if (_final) {
                    var dd = new u8(16);
                    wbytes(dd, 0, 0x8074B50);
                    wbytes(dd, 4, file.crc);
                    wbytes(dd, 8, cl);
                    wbytes(dd, 12, file.size);
                    chks.push(dd);
                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
                    if (tr) uf.r();
                    tr = 1;
                } else if (tr) pAll();
            }
        };
        this.u.push(uf);
    };
    /**
     * Ends the process of adding files and prepares to emit the final chunks.
     * This *must* be called after adding all desired files for the resulting
     * ZIP file to work properly.
     */ Zip.prototype.end = function() {
        var _this_1 = this;
        if (this.d & 2) {
            if (this.d & 1) throw 'stream finishing';
            throw 'stream finished';
        }
        if (this.d) this.e();
        else this.u.push({
            r: function r() {
                if (!(_this_1.d & 1)) return;
                _this_1.u.splice(-1, 1);
                _this_1.e();
            },
            t: function t() {}
        });
        this.d = 3;
    };
    Zip.prototype.e = function() {
        var bt = 0, l = 0, tl = 0;
        for(var _i = 0, _a = this.u; _i < _a.length; _i++){
            var f = _a[_i];
            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
        }
        var out = new u8(tl + 22);
        for(var _b = 0, _c = this.u; _b < _c.length; _b++){
            var f = _c[_b];
            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
    };
    /**
     * A method to terminate any internal workers used by the stream. Subsequent
     * calls to add() will fail.
     */ Zip.prototype.terminate = function() {
        for(var _i = 0, _a = this.u; _i < _a.length; _i++){
            var f = _a[_i];
            f.t();
        }
        this.d = 2;
    };
    return Zip;
}();
;
function zip(data, opts, cb) {
    if (!cb) cb = opts, opts = {};
    if (typeof cb != 'function') throw 'no callback';
    var r = {};
    fltn(data, '', r, opts);
    var k = Object.keys(r);
    var lft = k.length, o = 0, tot = 0;
    var slft = lft, files = new Array(lft);
    var term = [];
    var tAll = function tAll() {
        for(var i = 0; i < term.length; ++i)term[i]();
    };
    var cbf = function cbf() {
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        tot = 0;
        for(var i = 0; i < slft; ++i){
            var f = files[i];
            try {
                var l = f.c.length;
                wzh(out, tot, f, f.f, f.u, l);
                var badd = 30 + f.f.length + exfl(f.extra);
                var loc = tot + badd;
                out.set(f.c, loc);
                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
            } catch (e) {
                return cb(e, null);
            }
        }
        wzf(out, o, files.length, cdl, oe);
        cb(null, out);
    };
    if (!lft) cbf();
    var _loop_1 = function _loop_1(i) {
        var fn = k[i];
        var _a = r[fn], file = _a[0], p = _a[1];
        var c = crc(), size = file.length;
        c.p(file);
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        var compression = p.level == 0 ? 0 : 8;
        var cbl = function cbl(e, d) {
            if (e) {
                tAll();
                cb(e, null);
            } else {
                var l = d.length;
                files[i] = mrg(p, {
                    size: size,
                    crc: c.d(),
                    c: d,
                    f: f,
                    m: m,
                    u: s != fn.length || m && com.length != ms,
                    compression: compression
                });
                o += 30 + s + exl + l;
                tot += 76 + 2 * (s + exl) + (ms || 0) + l;
                if (!--lft) cbf();
            }
        };
        if (s > 65535) cbl('filename too long', null);
        if (!compression) cbl(null, file);
        else if (size < 160000) {
            try {
                cbl(null, deflateSync(file, p));
            } catch (e) {
                cbl(e, null);
            }
        } else term.push(deflate(file, p, cbl));
    };
    // Cannot use lft because it can decrease
    for(var i = 0; i < slft; ++i){
        _loop_1(i);
    }
    return tAll;
}
function zipSync(data, opts) {
    if (!opts) opts = {};
    var r = {};
    var files = [];
    fltn(data, '', r, opts);
    var o = 0;
    var tot = 0;
    for(var fn in r){
        var _a = r[fn], file = _a[0], p = _a[1];
        var compression = p.level == 0 ? 0 : 8;
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        if (s > 65535) throw 'filename too long';
        var d = compression ? deflateSync(file, p) : file, l = d.length;
        var c = crc();
        c.p(file);
        files.push(mrg(p, {
            size: file.length,
            crc: c.d(),
            c: d,
            f: f,
            m: m,
            u: s != fn.length || m && com.length != ms,
            o: o,
            compression: compression
        }));
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
    }
    var out = new u8(tot + 22), oe = o, cdl = tot - o;
    for(var i = 0; i < files.length; ++i){
        var f = files[i];
        wzh(out, f.o, f, f.f, f.u, f.c.length);
        var badd = 30 + f.f.length + exfl(f.extra);
        out.set(f.c, f.o + badd);
        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
    }
    wzf(out, o, files.length, cdl, oe);
    return out;
}
/**
 * Streaming pass-through decompression for ZIP archives
 */ var UnzipPassThrough = function() {
    function UnzipPassThrough() {}
    UnzipPassThrough.prototype.push = function(data, _final) {
        this.ondata(null, data, _final);
    };
    UnzipPassThrough.compression = 0;
    return UnzipPassThrough;
}();
;
/**
 * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
 * better performance.
 */ var UnzipInflate = function() {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */ function UnzipInflate() {
        var _this_1 = this;
        this.i = new Inflate(function(dat, _final) {
            _this_1.ondata(null, dat, _final);
        });
    }
    UnzipInflate.prototype.push = function(data, _final) {
        try {
            this.i.push(data, _final);
        } catch (e) {
            this.ondata(e, data, _final);
        }
    };
    UnzipInflate.compression = 8;
    return UnzipInflate;
}();
;
/**
 * Asynchronous streaming DEFLATE decompression for ZIP archives
 */ var AsyncUnzipInflate = function() {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */ function AsyncUnzipInflate(_, sz) {
        var _this_1 = this;
        if (sz < 320000) {
            this.i = new Inflate(function(dat, _final) {
                _this_1.ondata(null, dat, _final);
            });
        } else {
            this.i = new AsyncInflate(function(err, dat, _final) {
                _this_1.ondata(err, dat, _final);
            });
            this.terminate = this.i.terminate;
        }
    }
    AsyncUnzipInflate.prototype.push = function(data, _final) {
        if (this.i.terminate) data = slc(data, 0);
        this.i.push(data, _final);
    };
    AsyncUnzipInflate.compression = 8;
    return AsyncUnzipInflate;
}();
;
/**
 * A ZIP archive decompression stream that emits files as they are discovered
 */ var Unzip = function() {
    /**
     * Creates a ZIP decompression stream
     * @param cb The callback to call whenever a file in the ZIP archive is found
     */ function Unzip(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
            0: UnzipPassThrough
        };
        this.p = et;
    }
    /**
     * Pushes a chunk to be unzipped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */ Unzip.prototype.push = function(chunk, _final) {
        var _this_1 = this;
        if (!this.onfile) throw 'no callback';
        if (!this.p) throw 'stream finished';
        if (this.c > 0) {
            var len = Math.min(this.c, chunk.length);
            var toAdd = chunk.subarray(0, len);
            this.c -= len;
            if (this.d) this.d.push(toAdd, !this.c);
            else this.k[0].push(toAdd);
            chunk = chunk.subarray(len);
            if (chunk.length) return this.push(chunk, _final);
        } else {
            var f = 0, i = 0, is = void 0, buf = void 0;
            if (!this.p.length) buf = chunk;
            else if (!chunk.length) buf = this.p;
            else {
                buf = new u8(this.p.length + chunk.length);
                buf.set(this.p), buf.set(chunk, this.p.length);
            }
            var l = buf.length, oc = this.c, add = oc && this.d;
            var _loop_2 = function _loop_2() {
                var _a;
                var sig = b4(buf, i);
                if (sig == 0x4034B50) {
                    f = 1, is = i;
                    this_1.d = null;
                    this_1.c = 0;
                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
                    if (l > i + 30 + fnl + es) {
                        var chks_2 = [];
                        this_1.k.unshift(chks_2);
                        f = 2;
                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                        if (sc_1 == 4294967295) {
                            _a = dd ? [
                                -2
                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
                        } else if (dd) sc_1 = -1;
                        i += es;
                        this_1.c = sc_1;
                        var d_1;
                        var file_1 = {
                            name: fn_1,
                            compression: cmp_1,
                            start: function start() {
                                if (!file_1.ondata) throw 'no callback';
                                if (!sc_1) file_1.ondata(null, et, true);
                                else {
                                    var ctr = _this_1.o[cmp_1];
                                    if (!ctr) throw 'unknown compression type ' + cmp_1;
                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                                    d_1.ondata = function(err, dat, _final) {
                                        file_1.ondata(err, dat, _final);
                                    };
                                    for(var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++){
                                        var dat = chks_3[_i];
                                        d_1.push(dat, false);
                                    }
                                    if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;
                                    else d_1.push(et, true);
                                }
                            },
                            terminate: function terminate() {
                                if (d_1 && d_1.terminate) d_1.terminate();
                            }
                        };
                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;
                        this_1.onfile(file_1);
                    }
                    return "break";
                } else if (oc) {
                    if (sig == 0x8074B50) {
                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                        return "break";
                    } else if (sig == 0x2014B50) {
                        is = i -= 4, f = 3, this_1.c = 0;
                        return "break";
                    }
                }
            };
            var this_1 = this;
            for(; i < l - 4; ++i){
                var state_1 = _loop_2();
                if (state_1 === "break") break;
            }
            this.p = et;
            if (oc < 0) {
                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);
                if (add) add.push(dat, !!f);
                else this.k[+(f == 2)].push(dat);
            }
            if (f & 2) return this.push(buf.subarray(i), _final);
            this.p = buf.subarray(i);
        }
        if (_final) {
            if (this.c) throw 'invalid zip file';
            this.p = null;
        }
    };
    /**
     * Registers a decoder with the stream, allowing for files compressed with
     * the compression type provided to be expanded correctly
     * @param decoder The decoder constructor
     */ Unzip.prototype.register = function(decoder) {
        this.o[decoder.compression] = decoder;
    };
    return Unzip;
}();
;
function unzip(data, cb) {
    if (typeof cb != 'function') throw 'no callback';
    var term = [];
    var tAll = function tAll() {
        for(var i = 0; i < term.length; ++i)term[i]();
    };
    var files = {};
    var e = data.length - 22;
    for(; b4(data, e) != 0x6054B50; --e){
        if (!e || data.length - e > 65558) {
            cb('invalid zip file', null);
            return;
        }
    }
    ;
    var lft = b2(data, e + 8);
    if (!lft) cb(null, {});
    var c = lft;
    var o = b4(data, e + 16);
    var z = o == 4294967295;
    if (z) {
        e = b4(data, e - 12);
        if (b4(data, e) != 0x6064B50) {
            cb('invalid zip file', null);
            return;
        }
        c = lft = b4(data, e + 32);
        o = b4(data, e + 48);
    }
    var _loop_3 = function _loop_3(i) {
        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
        o = no;
        var cbl = function cbl(e, d) {
            if (e) {
                tAll();
                cb(e, null);
            } else {
                files[fn] = d;
                if (!--lft) cb(null, files);
            }
        };
        if (!c_1) cbl(null, slc(data, b, b + sc));
        else if (c_1 == 8) {
            var infl = data.subarray(b, b + sc);
            if (sc < 320000) {
                try {
                    cbl(null, inflateSync(infl, new u8(su)));
                } catch (e) {
                    cbl(e, null);
                }
            } else term.push(inflate(infl, {
                size: su
            }, cbl));
        } else cbl('unknown compression type ' + c_1, null);
    };
    for(var i = 0; i < c; ++i){
        _loop_3(i);
    }
    return tAll;
}
function unzipSync(data) {
    var files = {};
    var e = data.length - 22;
    for(; b4(data, e) != 0x6054B50; --e){
        if (!e || data.length - e > 65558) throw 'invalid zip file';
    }
    ;
    var c = b2(data, e + 8);
    if (!c) return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295;
    if (z) {
        e = b4(data, e - 12);
        if (b4(data, e) != 0x6064B50) throw 'invalid zip file';
        c = b4(data, e + 32);
        o = b4(data, e + 48);
    }
    for(var i = 0; i < c; ++i){
        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
        o = no;
        if (!c_2) files[fn] = slc(data, b, b + sc);
        else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));
        else throw 'unknown compression type ' + c_2;
    }
    return files;
}
}),
"[project]/andreas-technology-v2/node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @monogrid/gainmap-js v3.4.0
 * With , by MONOGRID <gainmap@monogrid.com>
 */ __turbopack_context__.s([
    "Q",
    ()=>QuadRenderer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.module.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
var getBufferForType = function(type, width, height) {
    var out;
    switch(type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"]:
            out = new Uint8ClampedArray(width * height * 4);
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
            out = new Uint16Array(width * height * 4);
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedIntType"]:
            out = new Uint32Array(width * height * 4);
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ByteType"]:
            out = new Int8Array(width * height * 4);
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShortType"]:
            out = new Int16Array(width * height * 4);
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntType"]:
            out = new Int32Array(width * height * 4);
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]:
            out = new Float32Array(width * height * 4);
            break;
        default:
            throw new Error('Unsupported data type');
    }
    return out;
};
var _canReadPixelsResult;
/**
 * Test if this browser implementation can correctly read pixels from the specified
 * Render target type.
 *
 * Runs only once
 *
 * @param type
 * @param renderer
 * @param camera
 * @param renderTargetOptions
 * @returns
 */ var canReadPixels = function(type, renderer, camera, renderTargetOptions) {
    if (_canReadPixelsResult !== undefined) return _canReadPixelsResult;
    var testRT = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](1, 1, renderTargetOptions);
    renderer.setRenderTarget(testRT);
    var mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](), new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
        color: 0xffffff
    }));
    renderer.render(mesh, camera);
    renderer.setRenderTarget(null);
    var out = getBufferForType(type, testRT.width, testRT.height);
    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);
    testRT.dispose();
    mesh.geometry.dispose();
    mesh.material.dispose();
    _canReadPixelsResult = out[0] !== 0;
    return _canReadPixelsResult;
};
/**
 * Utility class used for rendering a texture with a material
 *
 * @category Core
 * @group Core
 */ var QuadRenderer = /*#__PURE__*/ function() {
    "use strict";
    function QuadRenderer(options) {
        var _this = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, QuadRenderer);
        var _options_renderTargetOptions, _options_renderTargetOptions1, _options_renderTargetOptions2, _options_renderTargetOptions3, _options_renderTargetOptions4, _options_renderTargetOptions5, _options_renderTargetOptions6, _options_renderTargetOptions7, _options_renderTargetOptions8, _options_renderTargetOptions9, _options_renderTargetOptions10, _options_renderTargetOptions11, _options_renderTargetOptions12, _options_renderTargetOptions13, _options_renderTargetOptions14, _options_renderTargetOptions15;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_renderer", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_rendererIsDisposable", false);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_material", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_scene", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_camera", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_quad", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_renderTarget", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_width", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_height", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_type", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_colorSpace", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_supportsReadPixels", true);
        /**
     * Renders the input texture using the specified material
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "render", function() {
            _this._renderer.setRenderTarget(_this._renderTarget);
            try {
                _this._renderer.render(_this._scene, _this._camera);
            } catch (e) {
                _this._renderer.setRenderTarget(null);
                throw e;
            }
            _this._renderer.setRenderTarget(null);
        });
        this._width = options.width;
        this._height = options.height;
        this._type = options.type;
        this._colorSpace = options.colorSpace;
        var rtOptions = {
            // fixed options
            format: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
            depthBuffer: false,
            stencilBuffer: false,
            // user options
            type: this._type,
            colorSpace: this._colorSpace,
            anisotropy: ((_options_renderTargetOptions = options.renderTargetOptions) === null || _options_renderTargetOptions === void 0 ? void 0 : _options_renderTargetOptions.anisotropy) !== undefined ? (_options_renderTargetOptions1 = options.renderTargetOptions) === null || _options_renderTargetOptions1 === void 0 ? void 0 : _options_renderTargetOptions1.anisotropy : 1,
            generateMipmaps: ((_options_renderTargetOptions2 = options.renderTargetOptions) === null || _options_renderTargetOptions2 === void 0 ? void 0 : _options_renderTargetOptions2.generateMipmaps) !== undefined ? (_options_renderTargetOptions3 = options.renderTargetOptions) === null || _options_renderTargetOptions3 === void 0 ? void 0 : _options_renderTargetOptions3.generateMipmaps : false,
            magFilter: ((_options_renderTargetOptions4 = options.renderTargetOptions) === null || _options_renderTargetOptions4 === void 0 ? void 0 : _options_renderTargetOptions4.magFilter) !== undefined ? (_options_renderTargetOptions5 = options.renderTargetOptions) === null || _options_renderTargetOptions5 === void 0 ? void 0 : _options_renderTargetOptions5.magFilter : __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"],
            minFilter: ((_options_renderTargetOptions6 = options.renderTargetOptions) === null || _options_renderTargetOptions6 === void 0 ? void 0 : _options_renderTargetOptions6.minFilter) !== undefined ? (_options_renderTargetOptions7 = options.renderTargetOptions) === null || _options_renderTargetOptions7 === void 0 ? void 0 : _options_renderTargetOptions7.minFilter : __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"],
            samples: ((_options_renderTargetOptions8 = options.renderTargetOptions) === null || _options_renderTargetOptions8 === void 0 ? void 0 : _options_renderTargetOptions8.samples) !== undefined ? (_options_renderTargetOptions9 = options.renderTargetOptions) === null || _options_renderTargetOptions9 === void 0 ? void 0 : _options_renderTargetOptions9.samples : undefined,
            wrapS: ((_options_renderTargetOptions10 = options.renderTargetOptions) === null || _options_renderTargetOptions10 === void 0 ? void 0 : _options_renderTargetOptions10.wrapS) !== undefined ? (_options_renderTargetOptions11 = options.renderTargetOptions) === null || _options_renderTargetOptions11 === void 0 ? void 0 : _options_renderTargetOptions11.wrapS : __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"],
            wrapT: ((_options_renderTargetOptions12 = options.renderTargetOptions) === null || _options_renderTargetOptions12 === void 0 ? void 0 : _options_renderTargetOptions12.wrapT) !== undefined ? (_options_renderTargetOptions13 = options.renderTargetOptions) === null || _options_renderTargetOptions13 === void 0 ? void 0 : _options_renderTargetOptions13.wrapT : __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"]
        };
        this._material = options.material;
        if (options.renderer) {
            this._renderer = options.renderer;
        } else {
            this._renderer = QuadRenderer.instantiateRenderer();
            this._rendererIsDisposable = true;
        }
        this._scene = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
        this._camera = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"]();
        this._camera.position.set(0, 0, 10);
        this._camera.left = -0.5;
        this._camera.right = 0.5;
        this._camera.top = 0.5;
        this._camera.bottom = -0.5;
        this._camera.updateProjectionMatrix();
        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {
            var alternativeType;
            switch(this._type){
                case __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"] : undefined;
                    break;
            }
            if (alternativeType !== undefined) {
                console.warn("This browser does not support reading pixels from ".concat(this._type, " RenderTargets, switching to ").concat(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FloatType"]));
                this._type = alternativeType;
            } else {
                this._supportsReadPixels = false;
                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');
            }
        }
        this._quad = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](), this._material);
        this._quad.geometry.computeBoundingBox();
        this._scene.add(this._quad);
        this._renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](this.width, this.height, rtOptions);
        this._renderTarget.texture.mapping = ((_options_renderTargetOptions14 = options.renderTargetOptions) === null || _options_renderTargetOptions14 === void 0 ? void 0 : _options_renderTargetOptions14.mapping) !== undefined ? (_options_renderTargetOptions15 = options.renderTargetOptions) === null || _options_renderTargetOptions15 === void 0 ? void 0 : _options_renderTargetOptions15.mapping : __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UVMapping"];
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(QuadRenderer, [
        {
            /**
     * Obtains a Buffer containing the rendered texture.
     *
     * @throws Error if the browser cannot read pixels from this RenderTarget type.
     * @returns a TypedArray containing RGBA values from this renderer
     */ key: "toArray",
            value: function toArray() {
                if (!this._supportsReadPixels) throw new Error('Can\'t read pixels in this browser');
                var out = getBufferForType(this._type, this._width, this._height);
                this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);
                return out;
            }
        },
        {
            /**
     * Performs a readPixel operation in the renderTarget
     * and returns a DataTexture containing the read data
     *
     * @param options options
     * @returns
     */ key: "toDataTexture",
            value: function toDataTexture(options) {
                var returnValue = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataTexture"](// fixed values
                this.toArray(), this.width, this.height, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"], this._type, // user values
                (options === null || options === void 0 ? void 0 : options.mapping) || __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UVMapping"], (options === null || options === void 0 ? void 0 : options.wrapS) || __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"], (options === null || options === void 0 ? void 0 : options.wrapT) || __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"], (options === null || options === void 0 ? void 0 : options.magFilter) || __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"], (options === null || options === void 0 ? void 0 : options.minFilter) || __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"], (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, // fixed value
                __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearSRGBColorSpace"]);
                // set this afterwards, we can't set it in constructor
                returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;
                return returnValue;
            }
        },
        {
            /**
     * If using a disposable renderer, it will dispose it.
     */ key: "disposeOnDemandRenderer",
            value: function disposeOnDemandRenderer() {
                this._renderer.setRenderTarget(null);
                if (this._rendererIsDisposable) {
                    this._renderer.dispose();
                    this._renderer.forceContextLoss();
                }
            }
        },
        {
            /**
     * Will dispose of **all** assets used by this renderer.
     *
     *
     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later
     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`
     * or are otherwise done with it.
     *
     * @example
     * ```js
     * const loader = new HDRJPGLoader(renderer)
     * const result = await loader.loadAsync('gainmap.jpeg')
     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )
     * // DO NOT dispose the renderTarget here,
     * // it is used directly in the material
     * result.dispose()
     * ```
     *
     * @example
     * ```js
     * const loader = new HDRJPGLoader(renderer)
     * const pmremGenerator = new PMREMGenerator( renderer );
     * const result = await loader.loadAsync('gainmap.jpeg')
     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)
     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )
     * // renderTarget can be disposed here
     * // because it was used to generate a PMREM texture
     * result.dispose(true)
     * ```
     */ key: "dispose",
            value: function dispose(disposeRenderTarget) {
                this.disposeOnDemandRenderer();
                if (disposeRenderTarget) {
                    this.renderTarget.dispose();
                }
                // dispose shader material texture uniforms
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this.material, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"])) {
                    Object.values(this.material.uniforms).forEach(function(v) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(v.value, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"])) v.value.dispose();
                    });
                }
                // dispose other material properties
                Object.values(this.material).forEach(function(value) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(value, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"])) value.dispose();
                });
                this.material.dispose();
                this._quad.geometry.dispose();
            }
        },
        {
            key: "width",
            get: /**
     * Width of the texture
     */ function get() {
                return this._width;
            },
            set: function set(value) {
                this._width = value;
                this._renderTarget.setSize(this._width, this._height);
            }
        },
        {
            key: "height",
            get: /**
     * Height of the texture
     */ function get() {
                return this._height;
            },
            set: function set(value) {
                this._height = value;
                this._renderTarget.setSize(this._width, this._height);
            }
        },
        {
            key: "renderer",
            get: /**
     * The renderer used
     */ function get() {
                return this._renderer;
            }
        },
        {
            key: "renderTarget",
            get: /**
     * The `WebGLRenderTarget` used.
     */ function get() {
                return this._renderTarget;
            },
            set: function set(value) {
                this._renderTarget = value;
                this._width = value.width;
                this._height = value.height;
            // this._type = value.texture.type
            }
        },
        {
            key: "material",
            get: /**
     * The `Material` used.
     */ function get() {
                return this._material;
            }
        },
        {
            key: "type",
            get: /**
     *
     */ function get() {
                return this._type;
            }
        },
        {
            key: "colorSpace",
            get: function get() {
                return this._colorSpace;
            }
        }
    ], [
        {
            key: "instantiateRenderer",
            value: /**
     * Instantiates a temporary renderer
     *
     * @returns
     */ function instantiateRenderer() {
                var renderer = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["WebGLRenderer"]();
                renderer.setSize(128, 128);
                // renderer.outputColorSpace = SRGBColorSpace
                // renderer.toneMapping = LinearToneMapping
                // renderer.debug.checkShaderErrors = false
                // this._rendererIsDisposable = true
                return renderer;
            }
        }
    ]);
    return QuadRenderer;
}();
;
}),
"[project]/andreas-technology-v2/node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @monogrid/gainmap-js v3.4.0
 * With , by MONOGRID <gainmap@monogrid.com>
 */ __turbopack_context__.s([
    "G",
    ()=>GainMapNotFoundError,
    "L",
    ()=>LoaderBaseShared,
    "M",
    ()=>MPFExtractor,
    "X",
    ()=>XMPMetadataNotFoundError,
    "a",
    ()=>extractXMP,
    "c",
    ()=>createDecodeFunction,
    "e",
    ()=>extractGainmapFromJPEG
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_async_to_generator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread_props.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_wrap_native_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript) <export __generator as _>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
/**
 * Shared decode implementation factory
 * Creates a decode function that prepares a QuadRenderer with the given parameters
 */ function createDecodeFunction(config) {
    return function(params) {
        var sdr = params.sdr, gainMap = params.gainMap, renderer = params.renderer;
        if (sdr.colorSpace !== __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SRGBColorSpace"]) {
            console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');
            sdr.colorSpace = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SRGBColorSpace"];
        }
        sdr.needsUpdate = true;
        if (gainMap.colorSpace !== __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearSRGBColorSpace"]) {
            console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');
            gainMap.colorSpace = __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearSRGBColorSpace"];
        }
        gainMap.needsUpdate = true;
        var material = config.createMaterial((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, params), {
            sdr: sdr,
            gainMap: gainMap
        }));
        var quadRenderer = config.createQuadRenderer({
            width: sdr.image.width,
            height: sdr.image.height,
            type: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"],
            colorSpace: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearSRGBColorSpace"],
            material: material,
            renderer: renderer,
            renderTargetOptions: params.renderTargetOptions
        });
        return quadRenderer;
    };
}
var GainMapNotFoundError = /*#__PURE__*/ function(Error1) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GainMapNotFoundError, Error1);
    function GainMapNotFoundError() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GainMapNotFoundError);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GainMapNotFoundError, arguments);
    }
    return GainMapNotFoundError;
}((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Error));
var XMPMetadataNotFoundError = /*#__PURE__*/ function(Error1) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(XMPMetadataNotFoundError, Error1);
    function XMPMetadataNotFoundError() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, XMPMetadataNotFoundError);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, XMPMetadataNotFoundError, arguments);
    }
    return XMPMetadataNotFoundError;
}((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Error));
var getXMLValue = function(xml, tag, defaultValue) {
    // Check for attribute format first: tag="value"
    var attributeMatch = new RegExp("".concat(tag, '="([^"]*)"'), 'i').exec(xml);
    if (attributeMatch) return attributeMatch[1];
    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>
    var tagMatch = new RegExp("<".concat(tag, "[^>]*>([\\s\\S]*?)</").concat(tag, ">"), 'i').exec(xml);
    if (tagMatch) {
        // Check if it contains rdf:li elements
        var liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
        if (liValues && liValues.length === 3) {
            return liValues.map(function(v) {
                return v.replace(/<\/?rdf:li>/g, '');
            });
        }
        return tagMatch[1].trim();
    }
    if (defaultValue !== undefined) return defaultValue;
    throw new Error("Can't find ".concat(tag, " in gainmap metadata"));
};
var extractXMP = function(input) {
    var str;
    // support node test environment
    if (typeof TextDecoder !== 'undefined') str = new TextDecoder().decode(input);
    else str = input.toString();
    var start = str.indexOf('<x:xmpmeta');
    while(start !== -1){
        var end = str.indexOf('x:xmpmeta>', start);
        var xmpBlock = str.slice(start, end + 10);
        try {
            var gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');
            var gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');
            var gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');
            var offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');
            var offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');
            // These are always attributes, so we can use a simpler regex
            var hdrCapacityMinMatch = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(xmpBlock);
            var hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';
            var hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(xmpBlock);
            if (!hdrCapacityMaxMatch) throw new Error('Incomplete gainmap metadata');
            var hdrCapacityMax = hdrCapacityMaxMatch[1];
            return {
                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(function(v) {
                    return parseFloat(v);
                }) : [
                    parseFloat(gainMapMin),
                    parseFloat(gainMapMin),
                    parseFloat(gainMapMin)
                ],
                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(function(v) {
                    return parseFloat(v);
                }) : [
                    parseFloat(gainMapMax),
                    parseFloat(gainMapMax),
                    parseFloat(gainMapMax)
                ],
                gamma: Array.isArray(gamma) ? gamma.map(function(v) {
                    return parseFloat(v);
                }) : [
                    parseFloat(gamma),
                    parseFloat(gamma),
                    parseFloat(gamma)
                ],
                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(function(v) {
                    return parseFloat(v);
                }) : [
                    parseFloat(offsetSDR),
                    parseFloat(offsetSDR),
                    parseFloat(offsetSDR)
                ],
                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(function(v) {
                    return parseFloat(v);
                }) : [
                    parseFloat(offsetHDR),
                    parseFloat(offsetHDR),
                    parseFloat(offsetHDR)
                ],
                hdrCapacityMin: parseFloat(hdrCapacityMin),
                hdrCapacityMax: parseFloat(hdrCapacityMax)
            };
        } catch (e) {
        // Continue searching for another xmpmeta block if this one fails
        }
        start = str.indexOf('<x:xmpmeta', end);
    }
};
/**
 * MPF Extractor (Multi Picture Format Extractor)
 * By Henrik S Nilsson 2019
 *
 * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html
 * under "CIPA DC-007-Translation-2021 Multi-Picture Format"
 *
 * Overly commented, and without intention of being complete or production ready.
 * Created to extract depth maps from iPhone images, and to learn about image metadata.
 * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)
 */ var MPFExtractor = /*#__PURE__*/ function() {
    "use strict";
    function MPFExtractor(options) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, MPFExtractor);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "options", void 0);
        this.options = {
            debug: options && options.debug !== undefined ? options.debug : false,
            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,
            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true
        };
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(MPFExtractor, [
        {
            key: "extract",
            value: function extract(imageArrayBuffer) {
                var _this = this;
                return new Promise(function(resolve, reject) {
                    var debug = _this.options.debug;
                    var dataView = new DataView(imageArrayBuffer.buffer);
                    // If you're executing this line on a big endian machine, it'll be reversed.
                    // bigEnd further down though, refers to the endianness of the image itself.
                    if (dataView.getUint16(0) !== 0xffd8) {
                        reject(new Error('Not a valid jpeg'));
                        return;
                    }
                    var length = dataView.byteLength;
                    var offset = 2;
                    var loops = 0;
                    var marker; // APP# marker
                    while(offset < length){
                        if (++loops > 250) {
                            reject(new Error("Found no marker after ".concat(loops, " loops ")));
                            return;
                        }
                        if (dataView.getUint8(offset) !== 0xff) {
                            reject(new Error("Not a valid marker at offset 0x".concat(offset.toString(16), ", found: 0x").concat(dataView.getUint8(offset).toString(16))));
                            return;
                        }
                        marker = dataView.getUint8(offset + 1);
                        if (debug) console.log("Marker: ".concat(marker.toString(16)));
                        if (marker === 0xe2) {
                            if (debug) console.log('Found APP2 marker (0xffe2)');
                            // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.
                            // Great way to visualize image information in html is using Exiftool. E.g.:
                            // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html
                            var formatPt = offset + 4;
                            /*
                     *  Structure of the MP Format Identifier
                     *
                     *  Offset Addr.  | Code (Hex)  | Description
                     *  +00             ff            Marker Prefix      <-- offset
                     *  +01             e2            APP2
                     *  +02             #n            APP2 Field Length
                     *  +03             #n            APP2 Field Length
                     *  +04             4d            'M'                <-- formatPt
                     *  +05             50            'P'
                     *  +06             46            'F'
                     *  +07             00            NULL
                     *                                                   <-- tiffOffset
                     */ if (dataView.getUint32(formatPt) === 0x4d504600) {
                                // Found MPF tag, so we start dig out sub images
                                var tiffOffset = formatPt + 4;
                                var bigEnd = void 0; // Endianness from TIFF header
                                // Test for TIFF validity and endianness
                                // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian
                                if (dataView.getUint16(tiffOffset) === 0x4949) {
                                    bigEnd = false;
                                } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {
                                    bigEnd = true;
                                } else {
                                    reject(new Error('No valid endianness marker found in TIFF header'));
                                    return;
                                }
                                if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {
                                    reject(new Error('Not valid TIFF data! (no 0x002A marker)'));
                                    return;
                                }
                                // 32 bit number stating the offset from the start of the 8 Byte MP Header
                                // to MP Index IFD Least possible value is thus 8 (means 0 offset)
                                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);
                                if (firstIFDOffset < 0x00000008) {
                                    reject(new Error('Not valid TIFF data! (First offset less than 8)'));
                                    return;
                                }
                                // Move ahead to MP Index IFD
                                // Assume we're at the first IFD, so firstIFDOffset points to
                                // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,
                                // we fail silently here due to this assumption)
                                // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)
                                var dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)
                                var count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)
                                // Extract info from MPEntries (starting after Count)
                                var entriesStart = dirStart + 2;
                                var numberOfImages = 0;
                                for(var i = entriesStart; i < entriesStart + 12 * count; i += 12){
                                    // Each entry is 12 Bytes long
                                    // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images
                                    if (dataView.getUint16(i, !bigEnd) === 0xb001) {
                                        // stored in Last 4 bytes of its 12 Byte entry.
                                        numberOfImages = dataView.getUint32(i + 8, !bigEnd);
                                    }
                                }
                                var nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags
                                var MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;
                                var images = [];
                                for(var i1 = MPImageListValPt; i1 < MPImageListValPt + numberOfImages * 16; i1 += 16){
                                    var image = {
                                        MPType: dataView.getUint32(i1, !bigEnd),
                                        size: dataView.getUint32(i1 + 4, !bigEnd),
                                        // This offset is specified relative to the address of the MP Endian
                                        // field in the MP Header, unless the image is a First Individual Image,
                                        // in which case the value of the offset shall be NULL (0x00000000).
                                        dataOffset: dataView.getUint32(i1 + 8, !bigEnd),
                                        dependantImages: dataView.getUint32(i1 + 12, !bigEnd),
                                        start: -1,
                                        end: -1,
                                        isFII: false
                                    };
                                    if (!image.dataOffset) {
                                        // dataOffset is 0x00000000 for First Individual Image
                                        image.start = 0;
                                        image.isFII = true;
                                    } else {
                                        image.start = tiffOffset + image.dataOffset;
                                        image.isFII = false;
                                    }
                                    image.end = image.start + image.size;
                                    images.push(image);
                                }
                                if (_this.options.extractNonFII && images.length) {
                                    var bufferBlob = new Blob([
                                        dataView
                                    ]);
                                    var imgs = [];
                                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                    try {
                                        for(var _iterator = images[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                            var image1 = _step.value;
                                            if (image1.isFII && !_this.options.extractFII) {
                                                continue; // Skip FII
                                            }
                                            var imageBlob = bufferBlob.slice(image1.start, image1.end + 1, 'image/jpeg');
                                            // we don't need this
                                            // const imageUrl = URL.createObjectURL(imageBlob)
                                            // image.img = document.createElement('img')
                                            // image.img.src = imageUrl
                                            imgs.push(imageBlob);
                                        }
                                    } catch (err) {
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                                                _iterator["return"]();
                                            }
                                        } finally{
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                    }
                                    resolve(imgs);
                                }
                            }
                        }
                        offset += 2 + dataView.getUint16(offset + 2);
                    }
                });
            }
        }
    ]);
    return MPFExtractor;
}();
/**
 * Extracts XMP Metadata and the gain map recovery image
 * from a single JPEG file.
 *
 * @category Decoding Functions
 * @group Decoding Functions
 * @param jpegFile an `Uint8Array` containing and encoded JPEG file
 * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata
 * @throws Error if XMP Metadata is not found
 * @throws Error if Gain map image is not found
 * @example
 * import { FileLoader } from 'three'
 * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'
 *
 * const jpegFile = await new FileLoader()
 *  .setResponseType('arraybuffer')
 *  .loadAsync('image.jpg')
 *
 * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)
 */ var extractGainmapFromJPEG = function(jpegFile) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
        var metadata, mpfExtractor, images, _tmp, _, _1;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
            switch(_state.label){
                case 0:
                    metadata = extractXMP(jpegFile);
                    if (!metadata) throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');
                    mpfExtractor = new MPFExtractor({
                        extractFII: true,
                        extractNonFII: true
                    });
                    return [
                        4,
                        mpfExtractor.extract(jpegFile)
                    ];
                case 1:
                    images = _state.sent();
                    if (images.length !== 2) throw new GainMapNotFoundError('Gain map recovery image not found');
                    _tmp = {};
                    _ = Uint8Array.bind;
                    return [
                        4,
                        images[0].arrayBuffer()
                    ];
                case 2:
                    _tmp.sdr = new (_.apply(Uint8Array, [
                        void 0,
                        _state.sent()
                    ]));
                    _1 = Uint8Array.bind;
                    return [
                        4,
                        images[1].arrayBuffer()
                    ];
                case 3:
                    return [
                        2,
                        (_tmp.gainMap = new (_1.apply(Uint8Array, [
                            void 0,
                            _state.sent()
                        ])), _tmp.metadata = metadata, _tmp)
                    ];
            }
        });
    })();
};
/**
 * private function, async get image from blob
 *
 * @param blob
 * @returns
 */ var getHTMLImageFromBlob = function(blob) {
    return new Promise(function(resolve, reject) {
        var img = document.createElement('img');
        img.onload = function() {
            resolve(img);
        };
        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
        img.onerror = function(e) {
            reject(e);
        };
        img.src = URL.createObjectURL(blob);
    });
};
/**
 * Shared base class for loaders that extracts common logic
 */ var LoaderBaseShared = /*#__PURE__*/ function(Loader) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(LoaderBaseShared, Loader);
    function LoaderBaseShared(config, manager) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, LoaderBaseShared);
        var _this;
        _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, LoaderBaseShared, [
            manager
        ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_this, "_renderer", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_this, "_renderTargetOptions", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_this, "_internalLoadingManager", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_this, "_config", void 0);
        _this._config = config;
        if (config.renderer) _this._renderer = config.renderer;
        _this._internalLoadingManager = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoadingManager"]();
        return _this;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(LoaderBaseShared, [
        {
            key: "setRenderer",
            value: function setRenderer(renderer) {
                this._renderer = renderer;
                return this;
            }
        },
        {
            key: "setRenderTargetOptions",
            value: function setRenderTargetOptions(options) {
                this._renderTargetOptions = options;
                return this;
            }
        },
        {
            key: "prepareQuadRenderer",
            value: function prepareQuadRenderer() {
                if (!this._renderer) {
                    console.warn('WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');
                }
                var material = this._config.createMaterial({
                    gainMapMax: [
                        1,
                        1,
                        1
                    ],
                    gainMapMin: [
                        0,
                        0,
                        0
                    ],
                    gamma: [
                        1,
                        1,
                        1
                    ],
                    offsetHdr: [
                        1,
                        1,
                        1
                    ],
                    offsetSdr: [
                        1,
                        1,
                        1
                    ],
                    hdrCapacityMax: 1,
                    hdrCapacityMin: 0,
                    maxDisplayBoost: 1,
                    gainMap: new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"](),
                    sdr: new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]()
                });
                return this._config.createQuadRenderer({
                    width: 16,
                    height: 16,
                    type: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"],
                    colorSpace: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearSRGBColorSpace"],
                    material: material,
                    renderer: this._renderer,
                    renderTargetOptions: this._renderTargetOptions
                });
            }
        },
        {
            key: "processImages",
            value: function processImages(sdrBuffer, gainMapBuffer, imageOrientation) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    var gainMapBlob, sdrBlob, sdrImage, gainMapImage, needsFlip, res, res1;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                gainMapBlob = gainMapBuffer ? new Blob([
                                    gainMapBuffer
                                ], {
                                    type: 'image/jpeg'
                                }) : undefined;
                                sdrBlob = new Blob([
                                    sdrBuffer
                                ], {
                                    type: 'image/jpeg'
                                });
                                needsFlip = false;
                                if (!(typeof createImageBitmap === 'undefined')) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    Promise.all([
                                        gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),
                                        getHTMLImageFromBlob(sdrBlob)
                                    ])
                                ];
                            case 1:
                                res = _state.sent();
                                gainMapImage = res[0];
                                sdrImage = res[1];
                                needsFlip = imageOrientation === 'flipY';
                                return [
                                    3,
                                    4
                                ];
                            case 2:
                                return [
                                    4,
                                    Promise.all([
                                        gainMapBlob ? createImageBitmap(gainMapBlob, {
                                            imageOrientation: imageOrientation || 'flipY'
                                        }) : Promise.resolve(undefined),
                                        createImageBitmap(sdrBlob, {
                                            imageOrientation: imageOrientation || 'flipY'
                                        })
                                    ])
                                ];
                            case 3:
                                res1 = _state.sent();
                                gainMapImage = res1[0];
                                sdrImage = res1[1];
                                _state.label = 4;
                            case 4:
                                return [
                                    2,
                                    {
                                        sdrImage: sdrImage,
                                        gainMapImage: gainMapImage,
                                        needsFlip: needsFlip
                                    }
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "createTextures",
            value: function createTextures(sdrImage, gainMapImage, needsFlip) {
                var gainMap = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"](gainMapImage || new ImageData(2, 2), __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UVMapping"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipMapLinearFilter"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"], 1, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearSRGBColorSpace"]);
                gainMap.flipY = needsFlip;
                gainMap.needsUpdate = true;
                var sdr = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"](sdrImage, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UVMapping"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ClampToEdgeWrapping"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearFilter"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearMipMapLinearFilter"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"], __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnsignedByteType"], 1, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SRGBColorSpace"]);
                sdr.flipY = needsFlip;
                sdr.needsUpdate = true;
                return {
                    gainMap: gainMap,
                    sdr: sdr
                };
            }
        },
        {
            key: "updateQuadRenderer",
            value: function updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata) {
                quadRenderer.width = sdrImage.width;
                quadRenderer.height = sdrImage.height;
                quadRenderer.material.gainMap = gainMap;
                quadRenderer.material.sdr = sdr;
                quadRenderer.material.gainMapMin = metadata.gainMapMin;
                quadRenderer.material.gainMapMax = metadata.gainMapMax;
                quadRenderer.material.offsetHdr = metadata.offsetHdr;
                quadRenderer.material.offsetSdr = metadata.offsetSdr;
                quadRenderer.material.gamma = metadata.gamma;
                quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;
                quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;
                quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);
                quadRenderer.material.needsUpdate = true;
            }
        }
    ]);
    return LoaderBaseShared;
}(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Loader"]);
;
}),
"[project]/andreas-technology-v2/node_modules/@monogrid/gainmap-js/dist/decode.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/**
 * @monogrid/gainmap-js v3.4.0
 * With , by MONOGRID <gainmap@monogrid.com>
 */ __turbopack_context__.s([
    "GainMapDecoderMaterial",
    ()=>GainMapDecoderMaterial,
    "GainMapLoader",
    ()=>GainMapLoader,
    "HDRJPGLoader",
    ()=>HDRJPGLoader,
    "JPEGRLoader",
    ()=>HDRJPGLoader,
    "decode",
    ()=>decode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_async_to_generator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_object_spread_props.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript) <export __generator as _>");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$QuadRenderer$2d$Bj1xl_EK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$Loader$2d$DLI$2d$_JDP$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.core.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/andreas-technology-v2/node_modules/three/build/three.module.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
var vertexShader = /* glsl */ "\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
var fragmentShader = /* glsl */ "\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n";
/**
 * A Material which is able to decode the Gainmap into a full HDR Representation
 *
 * @category Materials
 * @group Materials
 */ var GainMapDecoderMaterial = /*#__PURE__*/ function(ShaderMaterial) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GainMapDecoderMaterial, ShaderMaterial);
    function GainMapDecoderMaterial(param) {
        var gamma = param.gamma, offsetHdr = param.offsetHdr, offsetSdr = param.offsetSdr, gainMapMin = param.gainMapMin, gainMapMax = param.gainMapMax, maxDisplayBoost = param.maxDisplayBoost, hdrCapacityMin = param.hdrCapacityMin, hdrCapacityMax = param.hdrCapacityMax, sdr = param.sdr, gainMap = param.gainMap;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GainMapDecoderMaterial);
        var _this;
        _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GainMapDecoderMaterial, [
            {
                name: 'GainMapDecoderMaterial',
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    sdr: {
                        value: sdr
                    },
                    gainMap: {
                        value: gainMap
                    },
                    gamma: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])
                    },
                    offsetHdr: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(offsetHdr)
                    },
                    offsetSdr: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(offsetSdr)
                    },
                    gainMapMin: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(gainMapMin)
                    },
                    gainMapMax: {
                        value: new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().fromArray(gainMapMax)
                    },
                    weightFactor: {
                        value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)
                    }
                },
                blending: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoBlending"],
                depthTest: false,
                depthWrite: false
            }
        ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_this, "_maxDisplayBoost", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_this, "_hdrCapacityMin", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_this, "_hdrCapacityMax", void 0);
        _this._maxDisplayBoost = maxDisplayBoost;
        _this._hdrCapacityMin = hdrCapacityMin;
        _this._hdrCapacityMax = hdrCapacityMax;
        _this.needsUpdate = true;
        _this.uniformsNeedUpdate = true;
        return _this;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GainMapDecoderMaterial, [
        {
            key: "sdr",
            get: function get() {
                return this.uniforms.sdr.value;
            },
            set: function set(value) {
                this.uniforms.sdr.value = value;
            }
        },
        {
            key: "gainMap",
            get: function get() {
                return this.uniforms.gainMap.value;
            },
            set: function set(value) {
                this.uniforms.gainMap.value = value;
            }
        },
        {
            key: "offsetHdr",
            get: /**
     * @see {@link GainMapMetadata.offsetHdr}
     */ function get() {
                return this.uniforms.offsetHdr.value.toArray();
            },
            set: function set(value) {
                this.uniforms.offsetHdr.value.fromArray(value);
            }
        },
        {
            key: "offsetSdr",
            get: /**
     * @see {@link GainMapMetadata.offsetSdr}
     */ function get() {
                return this.uniforms.offsetSdr.value.toArray();
            },
            set: function set(value) {
                this.uniforms.offsetSdr.value.fromArray(value);
            }
        },
        {
            key: "gainMapMin",
            get: /**
     * @see {@link GainMapMetadata.gainMapMin}
     */ function get() {
                return this.uniforms.gainMapMin.value.toArray();
            },
            set: function set(value) {
                this.uniforms.gainMapMin.value.fromArray(value);
            }
        },
        {
            key: "gainMapMax",
            get: /**
     * @see {@link GainMapMetadata.gainMapMax}
     */ function get() {
                return this.uniforms.gainMapMax.value.toArray();
            },
            set: function set(value) {
                this.uniforms.gainMapMax.value.fromArray(value);
            }
        },
        {
            key: "gamma",
            get: /**
     * @see {@link GainMapMetadata.gamma}
     */ function get() {
                var g = this.uniforms.gamma.value;
                return [
                    1 / g.x,
                    1 / g.y,
                    1 / g.z
                ];
            },
            set: function set(value) {
                var g = this.uniforms.gamma.value;
                g.x = 1.0 / value[0];
                g.y = 1.0 / value[1];
                g.z = 1.0 / value[2];
            }
        },
        {
            key: "hdrCapacityMin",
            get: /**
     * @see {@link GainMapMetadata.hdrCapacityMin}
     * @remarks Logarithmic space
     */ function get() {
                return this._hdrCapacityMin;
            },
            set: function set(value) {
                this._hdrCapacityMin = value;
                this.calculateWeight();
            }
        },
        {
            key: "hdrCapacityMax",
            get: /**
     * @see {@link GainMapMetadata.hdrCapacityMin}
     * @remarks Logarithmic space
     */ function get() {
                return this._hdrCapacityMax;
            },
            set: function set(value) {
                this._hdrCapacityMax = value;
                this.calculateWeight();
            }
        },
        {
            key: "maxDisplayBoost",
            get: /**
     * @see {@link GainmapDecodingParameters.maxDisplayBoost}
     * @remarks Non Logarithmic space
     */ function get() {
                return this._maxDisplayBoost;
            },
            set: function set(value) {
                this._maxDisplayBoost = Math.max(1, Math.min(65504, value));
                this.calculateWeight();
            }
        },
        {
            key: "calculateWeight",
            value: function calculateWeight() {
                var val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);
                this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));
            }
        }
    ]);
    return GainMapDecoderMaterial;
}(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]);
var decodeImpl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$Loader$2d$DLI$2d$_JDP$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])({
    renderer: __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["WebGLRenderer"],
    createMaterial: function(params) {
        return new GainMapDecoderMaterial(params);
    },
    createQuadRenderer: function(params) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$QuadRenderer$2d$Bj1xl_EK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Q"](params);
    }
});
/**
 * Decodes a gain map using a WebGL RenderTarget
 *
 * @category Decoding Functions
 * @group Decoding Functions
 * @example
 * import { decode } from '@monogrid/gainmap-js'
 * import {
 *   Mesh,
 *   MeshBasicMaterial,
 *   PerspectiveCamera,
 *   PlaneGeometry,
 *   Scene,
 *   TextureLoader,
 *   WebGLRenderer
 * } from 'three'
 *
 * const renderer = new WebGLRenderer()
 *
 * const textureLoader = new TextureLoader()
 *
 * // load SDR Representation
 * const sdr = await textureLoader.loadAsync('sdr.jpg')
 * // load Gain map recovery image
 * const gainMap = await textureLoader.loadAsync('gainmap.jpg')
 * // load metadata
 * const metadata = await (await fetch('metadata.json')).json()
 *
 * const result = decode({
 *   sdr,
 *   gainMap,
 *   // this allows to use `result.renderTarget.texture` directly
 *   renderer,
 *   // this will restore the full HDR range
 *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),
 *   ...metadata
 * })
 *
 * const scene = new Scene()
 * // `result` can be used to populate a Texture
 * const mesh = new Mesh(
 *   new PlaneGeometry(),
 *   new MeshBasicMaterial({ map: result.renderTarget.texture })
 * )
 * scene.add(mesh)
 * renderer.render(scene, new PerspectiveCamera())
 *
 * // result must be manually disposed
 * // when you are done using it
 * result.dispose()
 *
 * @param params
 * @returns
 * @throws {Error} if the WebGLRenderer fails to render the gain map
 */ var decode = function(params) {
    // Ensure renderer is defined for the base function
    if (!params.renderer) {
        throw new Error('Renderer is required for decode function');
    }
    var quadRenderer = decodeImpl((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread_props$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, params), {
        renderer: params.renderer
    }));
    try {
        quadRenderer.render();
    } catch (e) {
        quadRenderer.disposeOnDemandRenderer();
        throw e;
    }
    return quadRenderer;
};
/**
 * Base class for WebGL loaders
 * @template TUrl - The type of URL used to load resources
 */ var LoaderBaseWebGL = /*#__PURE__*/ function(LoaderBaseShared) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(LoaderBaseWebGL, LoaderBaseShared);
    function LoaderBaseWebGL(renderer, manager) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, LoaderBaseWebGL);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, LoaderBaseWebGL, [
            {
                renderer: renderer,
                createMaterial: function(params) {
                    return new GainMapDecoderMaterial(params);
                },
                createQuadRenderer: function(params) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$QuadRenderer$2d$Bj1xl_EK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Q"](params);
                }
            },
            manager
        ]);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(LoaderBaseWebGL, [
        {
            key: "render",
            value: /**
     * @private
     * @param quadRenderer
     * @param metadata
     * @param sdrBuffer
     * @param gainMapBuffer
     */ function render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    var _ref, sdrImage, gainMapImage, needsFlip, _this_createTextures, gainMap, sdr;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                return [
                                    4,
                                    this.processImages(sdrBuffer, gainMapBuffer, 'flipY')
                                ];
                            case 1:
                                _ref = _state.sent(), sdrImage = _ref.sdrImage, gainMapImage = _ref.gainMapImage, needsFlip = _ref.needsFlip;
                                _this_createTextures = this.createTextures(sdrImage, gainMapImage, needsFlip), gainMap = _this_createTextures.gainMap, sdr = _this_createTextures.sdr;
                                this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);
                                quadRenderer.render();
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        }
    ]);
    return LoaderBaseWebGL;
}(__TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$Loader$2d$DLI$2d$_JDP$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["L"]);
/**
 * A Three.js Loader for the gain map format.
 *
 * @category Loaders
 * @group Loaders
 *
 * @example
 * import { GainMapLoader } from '@monogrid/gainmap-js'
 * import {
 *   EquirectangularReflectionMapping,
 *   Mesh,
 *   MeshBasicMaterial,
 *   PerspectiveCamera,
 *   PlaneGeometry,
 *   Scene,
 *   WebGLRenderer
 * } from 'three'
 *
 * const renderer = new WebGLRenderer()
 *
 * const loader = new GainMapLoader(renderer)
 *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })
 *
 * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])
 * // `result` can be used to populate a Texture
 *
 * const scene = new Scene()
 * const mesh = new Mesh(
 *   new PlaneGeometry(),
 *   new MeshBasicMaterial({ map: result.renderTarget.texture })
 * )
 * scene.add(mesh)
 * renderer.render(scene, new PerspectiveCamera())
 *
 * // Starting from three.js r159
 * // `result.renderTarget.texture` can
 * // also be used as Equirectangular scene background
 * //
 * // it was previously needed to convert it
 * // to a DataTexture with `result.toDataTexture()`
 * scene.background = result.renderTarget.texture
 *
 * // result must be manually disposed
 * // when you are done using it
 * result.dispose()
 *
 */ var GainMapLoader = /*#__PURE__*/ function(LoaderBaseWebGL) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GainMapLoader, LoaderBaseWebGL);
    function GainMapLoader() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GainMapLoader);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, GainMapLoader, arguments);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(GainMapLoader, [
        {
            /**
     * Loads a gainmap using separate data
     * * sdr image
     * * gain map image
     * * metadata json
     *
     * useful for webp gain maps
     *
     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]
     * @param onLoad Load complete callback, will receive the result
     * @param onProgress Progress callback, will receive a `ProgressEvent`
     * @param onError Error callback
     * @returns
     */ key: "load",
            value: function load(param, onLoad, onProgress, onError) {
                var _this = this;
                var _param = (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(param, 3), sdrUrl = _param[0], gainMapUrl = _param[1], metadataUrl = _param[2];
                var quadRenderer = this.prepareQuadRenderer();
                var sdr;
                var gainMap;
                var metadata;
                var loadCheck = function() {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                        var error;
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    if (!(sdr && gainMap && metadata)) return [
                                        3,
                                        5
                                    ];
                                    _state.label = 1;
                                case 1:
                                    _state.trys.push([
                                        1,
                                        3,
                                        ,
                                        4
                                    ]);
                                    return [
                                        4,
                                        this.render(quadRenderer, metadata, sdr, gainMap)
                                    ];
                                case 2:
                                    _state.sent();
                                    return [
                                        3,
                                        4
                                    ];
                                case 3:
                                    error = _state.sent();
                                    this.manager.itemError(sdrUrl);
                                    this.manager.itemError(gainMapUrl);
                                    this.manager.itemError(metadataUrl);
                                    if (typeof onError === 'function') onError(error);
                                    quadRenderer.disposeOnDemandRenderer();
                                    return [
                                        2
                                    ];
                                case 4:
                                    if (typeof onLoad === 'function') onLoad(quadRenderer);
                                    this.manager.itemEnd(sdrUrl);
                                    this.manager.itemEnd(gainMapUrl);
                                    this.manager.itemEnd(metadataUrl);
                                    quadRenderer.disposeOnDemandRenderer();
                                    _state.label = 5;
                                case 5:
                                    return [
                                        2
                                    ];
                            }
                        });
                    }).call(_this);
                };
                var sdrLengthComputable = true;
                var sdrTotal = 0;
                var sdrLoaded = 0;
                var gainMapLengthComputable = true;
                var gainMapTotal = 0;
                var gainMapLoaded = 0;
                var metadataLengthComputable = true;
                var metadataTotal = 0;
                var metadataLoaded = 0;
                var progressHandler = function() {
                    if (typeof onProgress === 'function') {
                        var total = sdrTotal + gainMapTotal + metadataTotal;
                        var loaded = sdrLoaded + gainMapLoaded + metadataLoaded;
                        var lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;
                        onProgress(new ProgressEvent('progress', {
                            lengthComputable: lengthComputable,
                            loaded: loaded,
                            total: total
                        }));
                    }
                };
                this.manager.itemStart(sdrUrl);
                this.manager.itemStart(gainMapUrl);
                this.manager.itemStart(metadataUrl);
                var sdrLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this._internalLoadingManager);
                sdrLoader.setResponseType('arraybuffer');
                sdrLoader.setRequestHeader(this.requestHeader);
                sdrLoader.setPath(this.path);
                sdrLoader.setWithCredentials(this.withCredentials);
                sdrLoader.load(sdrUrl, function(buffer) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    /* istanbul ignore if
             this condition exists only because of three.js types + strict mode
            */ if (typeof buffer === 'string') throw new Error('Invalid sdr buffer');
                                    sdr = buffer;
                                    return [
                                        4,
                                        loadCheck()
                                    ];
                                case 1:
                                    _state.sent();
                                    return [
                                        2
                                    ];
                            }
                        });
                    })();
                }, function(e) {
                    sdrLengthComputable = e.lengthComputable;
                    sdrLoaded = e.loaded;
                    sdrTotal = e.total;
                    progressHandler();
                }, function(error) {
                    _this.manager.itemError(sdrUrl);
                    if (typeof onError === 'function') onError(error);
                });
                var gainMapLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this._internalLoadingManager);
                gainMapLoader.setResponseType('arraybuffer');
                gainMapLoader.setRequestHeader(this.requestHeader);
                gainMapLoader.setPath(this.path);
                gainMapLoader.setWithCredentials(this.withCredentials);
                gainMapLoader.load(gainMapUrl, function(buffer) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    /* istanbul ignore if
             this condition exists only because of three.js types + strict mode
            */ if (typeof buffer === 'string') throw new Error('Invalid gainmap buffer');
                                    gainMap = buffer;
                                    return [
                                        4,
                                        loadCheck()
                                    ];
                                case 1:
                                    _state.sent();
                                    return [
                                        2
                                    ];
                            }
                        });
                    })();
                }, function(e) {
                    gainMapLengthComputable = e.lengthComputable;
                    gainMapLoaded = e.loaded;
                    gainMapTotal = e.total;
                    progressHandler();
                }, function(error) {
                    _this.manager.itemError(gainMapUrl);
                    if (typeof onError === 'function') onError(error);
                });
                var metadataLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this._internalLoadingManager);
                // metadataLoader.setResponseType('json')
                metadataLoader.setRequestHeader(this.requestHeader);
                metadataLoader.setPath(this.path);
                metadataLoader.setWithCredentials(this.withCredentials);
                metadataLoader.load(metadataUrl, function(json) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    /* istanbul ignore if
             this condition exists only because of three.js types + strict mode
            */ if (typeof json !== 'string') throw new Error('Invalid metadata string');
                                    // TODO: implement check on JSON file and remove this eslint disable
                                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                    metadata = JSON.parse(json);
                                    return [
                                        4,
                                        loadCheck()
                                    ];
                                case 1:
                                    _state.sent();
                                    return [
                                        2
                                    ];
                            }
                        });
                    })();
                }, function(e) {
                    metadataLengthComputable = e.lengthComputable;
                    metadataLoaded = e.loaded;
                    metadataTotal = e.total;
                    progressHandler();
                }, function(error) {
                    _this.manager.itemError(metadataUrl);
                    if (typeof onError === 'function') onError(error);
                });
                return quadRenderer;
            }
        }
    ]);
    return GainMapLoader;
}(LoaderBaseWebGL);
/**
 * A Three.js Loader for a JPEG with embedded gainmap metadata.
 *
 * @category Loaders
 * @group Loaders
 *
 * @example
 * import { HDRJPGLoader } from '@monogrid/gainmap-js'
 * import {
 *   EquirectangularReflectionMapping,
 *   Mesh,
 *   MeshBasicMaterial,
 *   PerspectiveCamera,
 *   PlaneGeometry,
 *   Scene,
 *   WebGLRenderer
 * } from 'three'
 *
 * const renderer = new WebGLRenderer()
 *
 * const loader = new HDRJPGLoader(renderer)
 *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })
 *
 * const result = await loader.loadAsync('gainmap.jpeg')
 * // `result` can be used to populate a Texture
 *
 * const scene = new Scene()
 * const mesh = new Mesh(
 *   new PlaneGeometry(),
 *   new MeshBasicMaterial({ map: result.renderTarget.texture })
 * )
 * scene.add(mesh)
 * renderer.render(scene, new PerspectiveCamera())
 *
 * // Starting from three.js r159
 * // `result.renderTarget.texture` can
 * // also be used as Equirectangular scene background
 * //
 * // it was previously needed to convert it
 * // to a DataTexture with `result.toDataTexture()`
 * scene.background = result.renderTarget.texture
 *
 * // result must be manually disposed
 * // when you are done using it
 * result.dispose()
 *
 */ var HDRJPGLoader = /*#__PURE__*/ function(LoaderBaseWebGL) {
    "use strict";
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(HDRJPGLoader, LoaderBaseWebGL);
    function HDRJPGLoader() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, HDRJPGLoader);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, HDRJPGLoader, arguments);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(HDRJPGLoader, [
        {
            /**
     * Loads a JPEG containing gain map metadata
     * Renders a normal SDR image if gainmap data is not found
     *
     * @param url Path to a JPEG file containing embedded gain map metadata
     * @param onLoad Load complete callback, will receive the result
     * @param onProgress Progress callback, will receive a `ProgressEvent`
     * @param onError Error callback
     * @returns
     */ key: "load",
            value: function load(url, onLoad, onProgress, onError) {
                var _this = this;
                var quadRenderer = this.prepareQuadRenderer();
                var loader = new __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FileLoader"](this._internalLoadingManager);
                loader.setResponseType('arraybuffer');
                loader.setRequestHeader(this.requestHeader);
                loader.setPath(this.path);
                loader.setWithCredentials(this.withCredentials);
                this.manager.itemStart(url);
                loader.load(url, function(jpeg) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                        var jpegBuffer, sdrJPEG, gainMapJPEG, metadata, extractionResult, e, error;
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    /* istanbul ignore if
             this condition exists only because of three.js types + strict mode
            */ if (typeof jpeg === 'string') throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');
                                    jpegBuffer = new Uint8Array(jpeg);
                                    _state.label = 1;
                                case 1:
                                    _state.trys.push([
                                        1,
                                        3,
                                        ,
                                        4
                                    ]);
                                    return [
                                        4,
                                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$Loader$2d$DLI$2d$_JDP$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["e"])(jpegBuffer)
                                    ];
                                case 2:
                                    extractionResult = _state.sent();
                                    // gain map is successfully reconstructed
                                    sdrJPEG = extractionResult.sdr;
                                    gainMapJPEG = extractionResult.gainMap;
                                    metadata = extractionResult.metadata;
                                    return [
                                        3,
                                        4
                                    ];
                                case 3:
                                    e = _state.sent();
                                    // render the SDR version if this is not a gainmap
                                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(e, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$Loader$2d$DLI$2d$_JDP$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["X"]) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(e, __TURBOPACK__imported__module__$5b$project$5d2f$andreas$2d$technology$2d$v2$2f$node_modules$2f40$monogrid$2f$gainmap$2d$js$2f$dist$2f$Loader$2d$DLI$2d$_JDP$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["G"])) {
                                        console.warn("Failure to reconstruct an HDR image from ".concat(url, ": Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg"));
                                        metadata = {
                                            gainMapMin: [
                                                0,
                                                0,
                                                0
                                            ],
                                            gainMapMax: [
                                                1,
                                                1,
                                                1
                                            ],
                                            gamma: [
                                                1,
                                                1,
                                                1
                                            ],
                                            hdrCapacityMin: 0,
                                            hdrCapacityMax: 1,
                                            offsetHdr: [
                                                0,
                                                0,
                                                0
                                            ],
                                            offsetSdr: [
                                                0,
                                                0,
                                                0
                                            ]
                                        };
                                        sdrJPEG = jpegBuffer;
                                    } else {
                                        throw e;
                                    }
                                    return [
                                        3,
                                        4
                                    ];
                                case 4:
                                    _state.trys.push([
                                        4,
                                        6,
                                        ,
                                        7
                                    ]);
                                    return [
                                        4,
                                        this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG === null || gainMapJPEG === void 0 ? void 0 : gainMapJPEG.buffer)
                                    ];
                                case 5:
                                    _state.sent();
                                    return [
                                        3,
                                        7
                                    ];
                                case 6:
                                    error = _state.sent();
                                    this.manager.itemError(url);
                                    if (typeof onError === 'function') onError(error);
                                    quadRenderer.disposeOnDemandRenderer();
                                    return [
                                        2
                                    ];
                                case 7:
                                    if (typeof onLoad === 'function') onLoad(quadRenderer);
                                    this.manager.itemEnd(url);
                                    quadRenderer.disposeOnDemandRenderer();
                                    return [
                                        2
                                    ];
                            }
                        });
                    }).call(_this);
                }, onProgress, function(error) {
                    _this.manager.itemError(url);
                    if (typeof onError === 'function') onError(error);
                });
                return quadRenderer;
            }
        }
    ]);
    return HDRJPGLoader;
}(LoaderBaseWebGL);
;
}),
]);

//# sourceMappingURL=8e458_d5e222cc._.js.map